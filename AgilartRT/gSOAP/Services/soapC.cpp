/* soapC.cpp
   Generated by gSOAP 2.8.3 from upcb.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.3 2011-09-09 08:13:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor:
		return soap_in_ns1__ArrayOfSoapProgramDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapProgramDescriptor");
	case SOAP_TYPE_ns1__SoapDriverDescriptor:
		return soap_in_ns1__SoapDriverDescriptor(soap, NULL, NULL, "ns1:SoapDriverDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor:
		return soap_in_ns1__ArrayOfSoapDriverDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapDriverDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor:
		return soap_in_ns1__ArrayOfSoapWireDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapWireDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor:
		return soap_in_ns1__ArrayOfSoapDeviceDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapDeviceDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor:
		return soap_in_ns1__ArrayOfSoapConnectionPointDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapConnectionPointDescriptor");
	case SOAP_TYPE_ns1__SoapDeviceDescriptor:
		return soap_in_ns1__SoapDeviceDescriptor(soap, NULL, NULL, "ns1:SoapDeviceDescriptor");
	case SOAP_TYPE_ns1__SoapConnectionPointDescriptor:
		return soap_in_ns1__SoapConnectionPointDescriptor(soap, NULL, NULL, "ns1:SoapConnectionPointDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr:
		return soap_in_ns1__ArrayOfSoapWireConnectionPointDescr(soap, NULL, NULL, "ns1:ArrayOfSoapWireConnectionPointDescr");
	case SOAP_TYPE_ns1__SoapWireDescriptor:
		return soap_in_ns1__SoapWireDescriptor(soap, NULL, NULL, "ns1:SoapWireDescriptor");
	case SOAP_TYPE_ns1__SoapWireConnectionPointDescr:
		return soap_in_ns1__SoapWireConnectionPointDescr(soap, NULL, NULL, "ns1:SoapWireConnectionPointDescr");
	case SOAP_TYPE_ns1__SoapEventParameterDescriptor:
		return soap_in_ns1__SoapEventParameterDescriptor(soap, NULL, NULL, "ns1:SoapEventParameterDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor:
		return soap_in_ns1__ArrayOfSoapEventParameterDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapEventParameterDescriptor");
	case SOAP_TYPE_ns1__SoapEventDescriptor:
		return soap_in_ns1__SoapEventDescriptor(soap, NULL, NULL, "ns1:SoapEventDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor:
		return soap_in_ns1__ArrayOfSoapEventDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapEventDescriptor");
	case SOAP_TYPE_ns1__SoapCommandParameterDescriptor:
		return soap_in_ns1__SoapCommandParameterDescriptor(soap, NULL, NULL, "ns1:SoapCommandParameterDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor:
		return soap_in_ns1__ArrayOfSoapCommandParameterDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapCommandParameterDescriptor");
	case SOAP_TYPE_ns1__SoapCommandDescriptor:
		return soap_in_ns1__SoapCommandDescriptor(soap, NULL, NULL, "ns1:SoapCommandDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor:
		return soap_in_ns1__ArrayOfSoapCommandDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapCommandDescriptor");
	case SOAP_TYPE_ns1__SoapPinoutDescriptor:
		return soap_in_ns1__SoapPinoutDescriptor(soap, NULL, NULL, "ns1:SoapPinoutDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor:
		return soap_in_ns1__ArrayOfSoapPinoutDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapPinoutDescriptor");
	case SOAP_TYPE_ns1__SoapProgramMappingDescriptor:
		return soap_in_ns1__SoapProgramMappingDescriptor(soap, NULL, NULL, "ns1:SoapProgramMappingDescriptor");
	case SOAP_TYPE_ns1__SoapPropertyDescriptor:
		return soap_in_ns1__SoapPropertyDescriptor(soap, NULL, NULL, "ns1:SoapPropertyDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor:
		return soap_in_ns1__ArrayOfSoapPropertyDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapPropertyDescriptor");
	case SOAP_TYPE_ns1__SoapBaseObject:
		return soap_in_ns1__SoapBaseObject(soap, NULL, NULL, "ns1:SoapBaseObject");
	case SOAP_TYPE_ns1__SoapProgramDescriptor:
		return soap_in_ns1__SoapProgramDescriptor(soap, NULL, NULL, "ns1:SoapProgramDescriptor");
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatusResponse:
		return soap_in_PointerTo_ns1__GetRunningProgramsStatusResponse(soap, NULL, NULL, "ns1:GetRunningProgramsStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatus:
		return soap_in_PointerTo_ns1__GetRunningProgramsStatus(soap, NULL, NULL, "ns1:GetRunningProgramsStatus");
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatusResponse:
		return soap_in_PointerTo_ns1__GetProgramStatusResponse(soap, NULL, NULL, "ns1:GetProgramStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatus:
		return soap_in_PointerTo_ns1__GetProgramStatus(soap, NULL, NULL, "ns1:GetProgramStatus");
	case SOAP_TYPE_PointerTo_ns1__GetProgramResponse:
		return soap_in_PointerTo_ns1__GetProgramResponse(soap, NULL, NULL, "ns1:GetProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProgram:
		return soap_in_PointerTo_ns1__GetProgram(soap, NULL, NULL, "ns1:GetProgram");
	case SOAP_TYPE_PointerTo_ns1__GetProgramsResponse:
		return soap_in_PointerTo_ns1__GetProgramsResponse(soap, NULL, NULL, "ns1:GetProgramsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPrograms:
		return soap_in_PointerTo_ns1__GetPrograms(soap, NULL, NULL, "ns1:GetPrograms");
	case SOAP_TYPE_PointerTo_ns1__GetDriversResponse:
		return soap_in_PointerTo_ns1__GetDriversResponse(soap, NULL, NULL, "ns1:GetDriversResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDrivers:
		return soap_in_PointerTo_ns1__GetDrivers(soap, NULL, NULL, "ns1:GetDrivers");
	case SOAP_TYPE_PointerTo_ns1__GetDevicesResponse:
		return soap_in_PointerTo_ns1__GetDevicesResponse(soap, NULL, NULL, "ns1:GetDevicesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDevices:
		return soap_in_PointerTo_ns1__GetDevices(soap, NULL, NULL, "ns1:GetDevices");
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfoResponse:
		return soap_in_PointerTo_ns1__GetBoardInfoResponse(soap, NULL, NULL, "ns1:GetBoardInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfo:
		return soap_in_PointerTo_ns1__GetBoardInfo(soap, NULL, NULL, "ns1:GetBoardInfo");
	case SOAP_TYPE_PointerTo_ns1__StopProgramResponse:
		return soap_in_PointerTo_ns1__StopProgramResponse(soap, NULL, NULL, "ns1:StopProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__StopProgram:
		return soap_in_PointerTo_ns1__StopProgram(soap, NULL, NULL, "ns1:StopProgram");
	case SOAP_TYPE_PointerTo_ns1__StartProgramResponse:
		return soap_in_PointerTo_ns1__StartProgramResponse(soap, NULL, NULL, "ns1:StartProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__StartProgram:
		return soap_in_PointerTo_ns1__StartProgram(soap, NULL, NULL, "ns1:StartProgram");
	case SOAP_TYPE_PointerTo_ns1__AddProgramResponse:
		return soap_in_PointerTo_ns1__AddProgramResponse(soap, NULL, NULL, "ns1:AddProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__AddProgram:
		return soap_in_PointerTo_ns1__AddProgram(soap, NULL, NULL, "ns1:AddProgram");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapConnectionPointDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapConnectionPointDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireConnectionPointDescr:
		return soap_in_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, NULL, NULL, "ns1:ArrayOfSoapWireConnectionPointDescr");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventParameterDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapEventParameterDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandParameterDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapCommandParameterDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapEventDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapEventDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapCommandDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapCommandDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPinoutDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapPinoutDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapWireDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapWireDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapProgramDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapProgramDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapProgramDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDriverDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapDriverDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapDriverDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDeviceDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapDeviceDescriptor");
	case SOAP_TYPE_PointerTons1__SoapProgramMappingDescriptor:
		return soap_in_PointerTons1__SoapProgramMappingDescriptor(soap, NULL, NULL, "ns1:SoapProgramMappingDescriptor");
	case SOAP_TYPE_PointerTons1__SoapProgramDescriptor:
		return soap_in_PointerTons1__SoapProgramDescriptor(soap, NULL, NULL, "ns1:SoapProgramDescriptor");
	case SOAP_TYPE_PointerTons1__SoapDriverDescriptor:
		return soap_in_PointerTons1__SoapDriverDescriptor(soap, NULL, NULL, "ns1:SoapDriverDescriptor");
	case SOAP_TYPE_PointerTons1__SoapWireDescriptor:
		return soap_in_PointerTons1__SoapWireDescriptor(soap, NULL, NULL, "ns1:SoapWireDescriptor");
	case SOAP_TYPE_PointerTons1__SoapDeviceDescriptor:
		return soap_in_PointerTons1__SoapDeviceDescriptor(soap, NULL, NULL, "ns1:SoapDeviceDescriptor");
	case SOAP_TYPE_PointerTons1__SoapConnectionPointDescriptor:
		return soap_in_PointerTons1__SoapConnectionPointDescriptor(soap, NULL, NULL, "ns1:SoapConnectionPointDescriptor");
	case SOAP_TYPE_PointerTons1__SoapWireConnectionPointDescr:
		return soap_in_PointerTons1__SoapWireConnectionPointDescr(soap, NULL, NULL, "ns1:SoapWireConnectionPointDescr");
	case SOAP_TYPE_PointerTons1__SoapEventParameterDescriptor:
		return soap_in_PointerTons1__SoapEventParameterDescriptor(soap, NULL, NULL, "ns1:SoapEventParameterDescriptor");
	case SOAP_TYPE_PointerTons1__SoapEventDescriptor:
		return soap_in_PointerTons1__SoapEventDescriptor(soap, NULL, NULL, "ns1:SoapEventDescriptor");
	case SOAP_TYPE_PointerTons1__SoapCommandParameterDescriptor:
		return soap_in_PointerTons1__SoapCommandParameterDescriptor(soap, NULL, NULL, "ns1:SoapCommandParameterDescriptor");
	case SOAP_TYPE_PointerTons1__SoapCommandDescriptor:
		return soap_in_PointerTons1__SoapCommandDescriptor(soap, NULL, NULL, "ns1:SoapCommandDescriptor");
	case SOAP_TYPE_PointerTons1__SoapPinoutDescriptor:
		return soap_in_PointerTons1__SoapPinoutDescriptor(soap, NULL, NULL, "ns1:SoapPinoutDescriptor");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__SoapPropertyDescriptor:
		return soap_in_PointerTons1__SoapPropertyDescriptor(soap, NULL, NULL, "ns1:SoapPropertyDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPropertyDescriptor:
		return soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, NULL, NULL, "ns1:ArrayOfSoapPropertyDescriptor");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapProgramDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor;
			return soap_in_ns1__ArrayOfSoapProgramDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapDriverDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapDriverDescriptor;
			return soap_in_ns1__SoapDriverDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapDriverDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor;
			return soap_in_ns1__ArrayOfSoapDriverDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapWireDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor;
			return soap_in_ns1__ArrayOfSoapWireDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapDeviceDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor;
			return soap_in_ns1__ArrayOfSoapDeviceDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapConnectionPointDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor;
			return soap_in_ns1__ArrayOfSoapConnectionPointDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapDeviceDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapDeviceDescriptor;
			return soap_in_ns1__SoapDeviceDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapConnectionPointDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapConnectionPointDescriptor;
			return soap_in_ns1__SoapConnectionPointDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapWireConnectionPointDescr"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr;
			return soap_in_ns1__ArrayOfSoapWireConnectionPointDescr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapWireDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapWireDescriptor;
			return soap_in_ns1__SoapWireDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapWireConnectionPointDescr"))
		{	*type = SOAP_TYPE_ns1__SoapWireConnectionPointDescr;
			return soap_in_ns1__SoapWireConnectionPointDescr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapEventParameterDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapEventParameterDescriptor;
			return soap_in_ns1__SoapEventParameterDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapEventParameterDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor;
			return soap_in_ns1__ArrayOfSoapEventParameterDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapEventDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapEventDescriptor;
			return soap_in_ns1__SoapEventDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapEventDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor;
			return soap_in_ns1__ArrayOfSoapEventDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapCommandParameterDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapCommandParameterDescriptor;
			return soap_in_ns1__SoapCommandParameterDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapCommandParameterDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor;
			return soap_in_ns1__ArrayOfSoapCommandParameterDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapCommandDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapCommandDescriptor;
			return soap_in_ns1__SoapCommandDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapCommandDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor;
			return soap_in_ns1__ArrayOfSoapCommandDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapPinoutDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapPinoutDescriptor;
			return soap_in_ns1__SoapPinoutDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapPinoutDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor;
			return soap_in_ns1__ArrayOfSoapPinoutDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapProgramMappingDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapProgramMappingDescriptor;
			return soap_in_ns1__SoapProgramMappingDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapPropertyDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapPropertyDescriptor;
			return soap_in_ns1__SoapPropertyDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSoapPropertyDescriptor"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor;
			return soap_in_ns1__ArrayOfSoapPropertyDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapBaseObject"))
		{	*type = SOAP_TYPE_ns1__SoapBaseObject;
			return soap_in_ns1__SoapBaseObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapProgramDescriptor"))
		{	*type = SOAP_TYPE_ns1__SoapProgramDescriptor;
			return soap_in_ns1__SoapProgramDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetRunningProgramsStatusResponse"))
		{	*type = SOAP_TYPE__ns1__GetRunningProgramsStatusResponse;
			return soap_in__ns1__GetRunningProgramsStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRunningProgramsStatus"))
		{	*type = SOAP_TYPE__ns1__GetRunningProgramsStatus;
			return soap_in__ns1__GetRunningProgramsStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProgramStatusResponse"))
		{	*type = SOAP_TYPE__ns1__GetProgramStatusResponse;
			return soap_in__ns1__GetProgramStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProgramStatus"))
		{	*type = SOAP_TYPE__ns1__GetProgramStatus;
			return soap_in__ns1__GetProgramStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProgramResponse"))
		{	*type = SOAP_TYPE__ns1__GetProgramResponse;
			return soap_in__ns1__GetProgramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProgram"))
		{	*type = SOAP_TYPE__ns1__GetProgram;
			return soap_in__ns1__GetProgram(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProgramsResponse"))
		{	*type = SOAP_TYPE__ns1__GetProgramsResponse;
			return soap_in__ns1__GetProgramsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPrograms"))
		{	*type = SOAP_TYPE__ns1__GetPrograms;
			return soap_in__ns1__GetPrograms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDriversResponse"))
		{	*type = SOAP_TYPE__ns1__GetDriversResponse;
			return soap_in__ns1__GetDriversResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDrivers"))
		{	*type = SOAP_TYPE__ns1__GetDrivers;
			return soap_in__ns1__GetDrivers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevicesResponse"))
		{	*type = SOAP_TYPE__ns1__GetDevicesResponse;
			return soap_in__ns1__GetDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevices"))
		{	*type = SOAP_TYPE__ns1__GetDevices;
			return soap_in__ns1__GetDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBoardInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetBoardInfoResponse;
			return soap_in__ns1__GetBoardInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBoardInfo"))
		{	*type = SOAP_TYPE__ns1__GetBoardInfo;
			return soap_in__ns1__GetBoardInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopProgramResponse"))
		{	*type = SOAP_TYPE__ns1__StopProgramResponse;
			return soap_in__ns1__StopProgramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopProgram"))
		{	*type = SOAP_TYPE__ns1__StopProgram;
			return soap_in__ns1__StopProgram(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartProgramResponse"))
		{	*type = SOAP_TYPE__ns1__StartProgramResponse;
			return soap_in__ns1__StartProgramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartProgram"))
		{	*type = SOAP_TYPE__ns1__StartProgram;
			return soap_in__ns1__StartProgram(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddProgramResponse"))
		{	*type = SOAP_TYPE__ns1__AddProgramResponse;
			return soap_in__ns1__AddProgramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddProgram"))
		{	*type = SOAP_TYPE__ns1__AddProgram;
			return soap_in__ns1__AddProgram(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__GetRunningProgramsStatusResponse:
		return ((_ns1__GetRunningProgramsStatusResponse *)ptr)->soap_out(soap, "ns1:GetRunningProgramsStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__GetRunningProgramsStatus:
		return ((_ns1__GetRunningProgramsStatus *)ptr)->soap_out(soap, "ns1:GetRunningProgramsStatus", id, NULL);
	case SOAP_TYPE__ns1__GetProgramStatusResponse:
		return ((_ns1__GetProgramStatusResponse *)ptr)->soap_out(soap, "ns1:GetProgramStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__GetProgramStatus:
		return ((_ns1__GetProgramStatus *)ptr)->soap_out(soap, "ns1:GetProgramStatus", id, NULL);
	case SOAP_TYPE__ns1__GetProgramResponse:
		return ((_ns1__GetProgramResponse *)ptr)->soap_out(soap, "ns1:GetProgramResponse", id, NULL);
	case SOAP_TYPE__ns1__GetProgram:
		return ((_ns1__GetProgram *)ptr)->soap_out(soap, "ns1:GetProgram", id, NULL);
	case SOAP_TYPE__ns1__GetProgramsResponse:
		return ((_ns1__GetProgramsResponse *)ptr)->soap_out(soap, "ns1:GetProgramsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPrograms:
		return ((_ns1__GetPrograms *)ptr)->soap_out(soap, "ns1:GetPrograms", id, NULL);
	case SOAP_TYPE__ns1__GetDriversResponse:
		return ((_ns1__GetDriversResponse *)ptr)->soap_out(soap, "ns1:GetDriversResponse", id, NULL);
	case SOAP_TYPE__ns1__GetDrivers:
		return ((_ns1__GetDrivers *)ptr)->soap_out(soap, "ns1:GetDrivers", id, NULL);
	case SOAP_TYPE__ns1__GetDevicesResponse:
		return ((_ns1__GetDevicesResponse *)ptr)->soap_out(soap, "ns1:GetDevicesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetDevices:
		return ((_ns1__GetDevices *)ptr)->soap_out(soap, "ns1:GetDevices", id, NULL);
	case SOAP_TYPE__ns1__GetBoardInfoResponse:
		return ((_ns1__GetBoardInfoResponse *)ptr)->soap_out(soap, "ns1:GetBoardInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetBoardInfo:
		return ((_ns1__GetBoardInfo *)ptr)->soap_out(soap, "ns1:GetBoardInfo", id, NULL);
	case SOAP_TYPE__ns1__StopProgramResponse:
		return ((_ns1__StopProgramResponse *)ptr)->soap_out(soap, "ns1:StopProgramResponse", id, NULL);
	case SOAP_TYPE__ns1__StopProgram:
		return ((_ns1__StopProgram *)ptr)->soap_out(soap, "ns1:StopProgram", id, NULL);
	case SOAP_TYPE__ns1__StartProgramResponse:
		return ((_ns1__StartProgramResponse *)ptr)->soap_out(soap, "ns1:StartProgramResponse", id, NULL);
	case SOAP_TYPE__ns1__StartProgram:
		return ((_ns1__StartProgram *)ptr)->soap_out(soap, "ns1:StartProgram", id, NULL);
	case SOAP_TYPE__ns1__AddProgramResponse:
		return ((_ns1__AddProgramResponse *)ptr)->soap_out(soap, "ns1:AddProgramResponse", id, NULL);
	case SOAP_TYPE__ns1__AddProgram:
		return ((_ns1__AddProgram *)ptr)->soap_out(soap, "ns1:AddProgram", id, NULL);
	case SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor:
		return ((ns1__ArrayOfSoapProgramDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapProgramDescriptor");
	case SOAP_TYPE_ns1__SoapDriverDescriptor:
		return ((ns1__SoapDriverDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapDriverDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor:
		return ((ns1__ArrayOfSoapDriverDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapDriverDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor:
		return ((ns1__ArrayOfSoapWireDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapWireDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor:
		return ((ns1__ArrayOfSoapDeviceDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapDeviceDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor:
		return ((ns1__ArrayOfSoapConnectionPointDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapConnectionPointDescriptor");
	case SOAP_TYPE_ns1__SoapDeviceDescriptor:
		return ((ns1__SoapDeviceDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapDeviceDescriptor");
	case SOAP_TYPE_ns1__SoapConnectionPointDescriptor:
		return ((ns1__SoapConnectionPointDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapConnectionPointDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr:
		return ((ns1__ArrayOfSoapWireConnectionPointDescr *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapWireConnectionPointDescr");
	case SOAP_TYPE_ns1__SoapWireDescriptor:
		return ((ns1__SoapWireDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapWireDescriptor");
	case SOAP_TYPE_ns1__SoapWireConnectionPointDescr:
		return ((ns1__SoapWireConnectionPointDescr *)ptr)->soap_out(soap, tag, id, "ns1:SoapWireConnectionPointDescr");
	case SOAP_TYPE_ns1__SoapEventParameterDescriptor:
		return ((ns1__SoapEventParameterDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapEventParameterDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor:
		return ((ns1__ArrayOfSoapEventParameterDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapEventParameterDescriptor");
	case SOAP_TYPE_ns1__SoapEventDescriptor:
		return ((ns1__SoapEventDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapEventDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor:
		return ((ns1__ArrayOfSoapEventDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapEventDescriptor");
	case SOAP_TYPE_ns1__SoapCommandParameterDescriptor:
		return ((ns1__SoapCommandParameterDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapCommandParameterDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor:
		return ((ns1__ArrayOfSoapCommandParameterDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapCommandParameterDescriptor");
	case SOAP_TYPE_ns1__SoapCommandDescriptor:
		return ((ns1__SoapCommandDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapCommandDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor:
		return ((ns1__ArrayOfSoapCommandDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapCommandDescriptor");
	case SOAP_TYPE_ns1__SoapPinoutDescriptor:
		return ((ns1__SoapPinoutDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapPinoutDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor:
		return ((ns1__ArrayOfSoapPinoutDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapPinoutDescriptor");
	case SOAP_TYPE_ns1__SoapProgramMappingDescriptor:
		return ((ns1__SoapProgramMappingDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapProgramMappingDescriptor");
	case SOAP_TYPE_ns1__SoapPropertyDescriptor:
		return ((ns1__SoapPropertyDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapPropertyDescriptor");
	case SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor:
		return ((ns1__ArrayOfSoapPropertyDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSoapPropertyDescriptor");
	case SOAP_TYPE_ns1__SoapBaseObject:
		return ((ns1__SoapBaseObject *)ptr)->soap_out(soap, tag, id, "ns1:SoapBaseObject");
	case SOAP_TYPE_ns1__SoapProgramDescriptor:
		return ((ns1__SoapProgramDescriptor *)ptr)->soap_out(soap, tag, id, "ns1:SoapProgramDescriptor");
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatusResponse:
		return soap_out_PointerTo_ns1__GetRunningProgramsStatusResponse(soap, tag, id, (_ns1__GetRunningProgramsStatusResponse *const*)ptr, "ns1:GetRunningProgramsStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatus:
		return soap_out_PointerTo_ns1__GetRunningProgramsStatus(soap, tag, id, (_ns1__GetRunningProgramsStatus *const*)ptr, "ns1:GetRunningProgramsStatus");
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatusResponse:
		return soap_out_PointerTo_ns1__GetProgramStatusResponse(soap, tag, id, (_ns1__GetProgramStatusResponse *const*)ptr, "ns1:GetProgramStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatus:
		return soap_out_PointerTo_ns1__GetProgramStatus(soap, tag, id, (_ns1__GetProgramStatus *const*)ptr, "ns1:GetProgramStatus");
	case SOAP_TYPE_PointerTo_ns1__GetProgramResponse:
		return soap_out_PointerTo_ns1__GetProgramResponse(soap, tag, id, (_ns1__GetProgramResponse *const*)ptr, "ns1:GetProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProgram:
		return soap_out_PointerTo_ns1__GetProgram(soap, tag, id, (_ns1__GetProgram *const*)ptr, "ns1:GetProgram");
	case SOAP_TYPE_PointerTo_ns1__GetProgramsResponse:
		return soap_out_PointerTo_ns1__GetProgramsResponse(soap, tag, id, (_ns1__GetProgramsResponse *const*)ptr, "ns1:GetProgramsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPrograms:
		return soap_out_PointerTo_ns1__GetPrograms(soap, tag, id, (_ns1__GetPrograms *const*)ptr, "ns1:GetPrograms");
	case SOAP_TYPE_PointerTo_ns1__GetDriversResponse:
		return soap_out_PointerTo_ns1__GetDriversResponse(soap, tag, id, (_ns1__GetDriversResponse *const*)ptr, "ns1:GetDriversResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDrivers:
		return soap_out_PointerTo_ns1__GetDrivers(soap, tag, id, (_ns1__GetDrivers *const*)ptr, "ns1:GetDrivers");
	case SOAP_TYPE_PointerTo_ns1__GetDevicesResponse:
		return soap_out_PointerTo_ns1__GetDevicesResponse(soap, tag, id, (_ns1__GetDevicesResponse *const*)ptr, "ns1:GetDevicesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDevices:
		return soap_out_PointerTo_ns1__GetDevices(soap, tag, id, (_ns1__GetDevices *const*)ptr, "ns1:GetDevices");
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfoResponse:
		return soap_out_PointerTo_ns1__GetBoardInfoResponse(soap, tag, id, (_ns1__GetBoardInfoResponse *const*)ptr, "ns1:GetBoardInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfo:
		return soap_out_PointerTo_ns1__GetBoardInfo(soap, tag, id, (_ns1__GetBoardInfo *const*)ptr, "ns1:GetBoardInfo");
	case SOAP_TYPE_PointerTo_ns1__StopProgramResponse:
		return soap_out_PointerTo_ns1__StopProgramResponse(soap, tag, id, (_ns1__StopProgramResponse *const*)ptr, "ns1:StopProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__StopProgram:
		return soap_out_PointerTo_ns1__StopProgram(soap, tag, id, (_ns1__StopProgram *const*)ptr, "ns1:StopProgram");
	case SOAP_TYPE_PointerTo_ns1__StartProgramResponse:
		return soap_out_PointerTo_ns1__StartProgramResponse(soap, tag, id, (_ns1__StartProgramResponse *const*)ptr, "ns1:StartProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__StartProgram:
		return soap_out_PointerTo_ns1__StartProgram(soap, tag, id, (_ns1__StartProgram *const*)ptr, "ns1:StartProgram");
	case SOAP_TYPE_PointerTo_ns1__AddProgramResponse:
		return soap_out_PointerTo_ns1__AddProgramResponse(soap, tag, id, (_ns1__AddProgramResponse *const*)ptr, "ns1:AddProgramResponse");
	case SOAP_TYPE_PointerTo_ns1__AddProgram:
		return soap_out_PointerTo_ns1__AddProgram(soap, tag, id, (_ns1__AddProgram *const*)ptr, "ns1:AddProgram");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapConnectionPointDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, tag, id, (ns1__ArrayOfSoapConnectionPointDescriptor *const*)ptr, "ns1:ArrayOfSoapConnectionPointDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireConnectionPointDescr:
		return soap_out_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, tag, id, (ns1__ArrayOfSoapWireConnectionPointDescr *const*)ptr, "ns1:ArrayOfSoapWireConnectionPointDescr");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventParameterDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, tag, id, (ns1__ArrayOfSoapEventParameterDescriptor *const*)ptr, "ns1:ArrayOfSoapEventParameterDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandParameterDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, tag, id, (ns1__ArrayOfSoapCommandParameterDescriptor *const*)ptr, "ns1:ArrayOfSoapCommandParameterDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapEventDescriptor(soap, tag, id, (ns1__ArrayOfSoapEventDescriptor *const*)ptr, "ns1:ArrayOfSoapEventDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapCommandDescriptor(soap, tag, id, (ns1__ArrayOfSoapCommandDescriptor *const*)ptr, "ns1:ArrayOfSoapCommandDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPinoutDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, tag, id, (ns1__ArrayOfSoapPinoutDescriptor *const*)ptr, "ns1:ArrayOfSoapPinoutDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapWireDescriptor(soap, tag, id, (ns1__ArrayOfSoapWireDescriptor *const*)ptr, "ns1:ArrayOfSoapWireDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapProgramDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapProgramDescriptor(soap, tag, id, (ns1__ArrayOfSoapProgramDescriptor *const*)ptr, "ns1:ArrayOfSoapProgramDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDriverDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapDriverDescriptor(soap, tag, id, (ns1__ArrayOfSoapDriverDescriptor *const*)ptr, "ns1:ArrayOfSoapDriverDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDeviceDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, tag, id, (ns1__ArrayOfSoapDeviceDescriptor *const*)ptr, "ns1:ArrayOfSoapDeviceDescriptor");
	case SOAP_TYPE_PointerTons1__SoapProgramMappingDescriptor:
		return soap_out_PointerTons1__SoapProgramMappingDescriptor(soap, tag, id, (ns1__SoapProgramMappingDescriptor *const*)ptr, "ns1:SoapProgramMappingDescriptor");
	case SOAP_TYPE_PointerTons1__SoapProgramDescriptor:
		return soap_out_PointerTons1__SoapProgramDescriptor(soap, tag, id, (ns1__SoapProgramDescriptor *const*)ptr, "ns1:SoapProgramDescriptor");
	case SOAP_TYPE_PointerTons1__SoapDriverDescriptor:
		return soap_out_PointerTons1__SoapDriverDescriptor(soap, tag, id, (ns1__SoapDriverDescriptor *const*)ptr, "ns1:SoapDriverDescriptor");
	case SOAP_TYPE_PointerTons1__SoapWireDescriptor:
		return soap_out_PointerTons1__SoapWireDescriptor(soap, tag, id, (ns1__SoapWireDescriptor *const*)ptr, "ns1:SoapWireDescriptor");
	case SOAP_TYPE_PointerTons1__SoapDeviceDescriptor:
		return soap_out_PointerTons1__SoapDeviceDescriptor(soap, tag, id, (ns1__SoapDeviceDescriptor *const*)ptr, "ns1:SoapDeviceDescriptor");
	case SOAP_TYPE_PointerTons1__SoapConnectionPointDescriptor:
		return soap_out_PointerTons1__SoapConnectionPointDescriptor(soap, tag, id, (ns1__SoapConnectionPointDescriptor *const*)ptr, "ns1:SoapConnectionPointDescriptor");
	case SOAP_TYPE_PointerTons1__SoapWireConnectionPointDescr:
		return soap_out_PointerTons1__SoapWireConnectionPointDescr(soap, tag, id, (ns1__SoapWireConnectionPointDescr *const*)ptr, "ns1:SoapWireConnectionPointDescr");
	case SOAP_TYPE_PointerTons1__SoapEventParameterDescriptor:
		return soap_out_PointerTons1__SoapEventParameterDescriptor(soap, tag, id, (ns1__SoapEventParameterDescriptor *const*)ptr, "ns1:SoapEventParameterDescriptor");
	case SOAP_TYPE_PointerTons1__SoapEventDescriptor:
		return soap_out_PointerTons1__SoapEventDescriptor(soap, tag, id, (ns1__SoapEventDescriptor *const*)ptr, "ns1:SoapEventDescriptor");
	case SOAP_TYPE_PointerTons1__SoapCommandParameterDescriptor:
		return soap_out_PointerTons1__SoapCommandParameterDescriptor(soap, tag, id, (ns1__SoapCommandParameterDescriptor *const*)ptr, "ns1:SoapCommandParameterDescriptor");
	case SOAP_TYPE_PointerTons1__SoapCommandDescriptor:
		return soap_out_PointerTons1__SoapCommandDescriptor(soap, tag, id, (ns1__SoapCommandDescriptor *const*)ptr, "ns1:SoapCommandDescriptor");
	case SOAP_TYPE_PointerTons1__SoapPinoutDescriptor:
		return soap_out_PointerTons1__SoapPinoutDescriptor(soap, tag, id, (ns1__SoapPinoutDescriptor *const*)ptr, "ns1:SoapPinoutDescriptor");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__SoapPropertyDescriptor:
		return soap_out_PointerTons1__SoapPropertyDescriptor(soap, tag, id, (ns1__SoapPropertyDescriptor *const*)ptr, "ns1:SoapPropertyDescriptor");
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPropertyDescriptor:
		return soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, tag, id, (ns1__ArrayOfSoapPropertyDescriptor *const*)ptr, "ns1:ArrayOfSoapPropertyDescriptor");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__GetRunningProgramsStatusResponse:
		((_ns1__GetRunningProgramsStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRunningProgramsStatus:
		((_ns1__GetRunningProgramsStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProgramStatusResponse:
		((_ns1__GetProgramStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProgramStatus:
		((_ns1__GetProgramStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProgramResponse:
		((_ns1__GetProgramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProgram:
		((_ns1__GetProgram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProgramsResponse:
		((_ns1__GetProgramsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPrograms:
		((_ns1__GetPrograms *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDriversResponse:
		((_ns1__GetDriversResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDrivers:
		((_ns1__GetDrivers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevicesResponse:
		((_ns1__GetDevicesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevices:
		((_ns1__GetDevices *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBoardInfoResponse:
		((_ns1__GetBoardInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBoardInfo:
		((_ns1__GetBoardInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopProgramResponse:
		((_ns1__StopProgramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopProgram:
		((_ns1__StopProgram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartProgramResponse:
		((_ns1__StartProgramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartProgram:
		((_ns1__StartProgram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddProgramResponse:
		((_ns1__AddProgramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddProgram:
		((_ns1__AddProgram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor:
		((ns1__ArrayOfSoapProgramDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapDriverDescriptor:
		((ns1__SoapDriverDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor:
		((ns1__ArrayOfSoapDriverDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor:
		((ns1__ArrayOfSoapWireDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor:
		((ns1__ArrayOfSoapDeviceDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor:
		((ns1__ArrayOfSoapConnectionPointDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapDeviceDescriptor:
		((ns1__SoapDeviceDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapConnectionPointDescriptor:
		((ns1__SoapConnectionPointDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr:
		((ns1__ArrayOfSoapWireConnectionPointDescr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapWireDescriptor:
		((ns1__SoapWireDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapWireConnectionPointDescr:
		((ns1__SoapWireConnectionPointDescr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapEventParameterDescriptor:
		((ns1__SoapEventParameterDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor:
		((ns1__ArrayOfSoapEventParameterDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapEventDescriptor:
		((ns1__SoapEventDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor:
		((ns1__ArrayOfSoapEventDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapCommandParameterDescriptor:
		((ns1__SoapCommandParameterDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor:
		((ns1__ArrayOfSoapCommandParameterDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapCommandDescriptor:
		((ns1__SoapCommandDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor:
		((ns1__ArrayOfSoapCommandDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapPinoutDescriptor:
		((ns1__SoapPinoutDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor:
		((ns1__ArrayOfSoapPinoutDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapProgramMappingDescriptor:
		((ns1__SoapProgramMappingDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapPropertyDescriptor:
		((ns1__SoapPropertyDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor:
		((ns1__ArrayOfSoapPropertyDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapBaseObject:
		((ns1__SoapBaseObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapProgramDescriptor:
		((ns1__SoapProgramDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__GetRunningProgramsStatus:
		soap_serialize___ns1__GetRunningProgramsStatus(soap, (const struct __ns1__GetRunningProgramsStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__GetProgramStatus:
		soap_serialize___ns1__GetProgramStatus(soap, (const struct __ns1__GetProgramStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__GetProgram:
		soap_serialize___ns1__GetProgram(soap, (const struct __ns1__GetProgram *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPrograms:
		soap_serialize___ns1__GetPrograms(soap, (const struct __ns1__GetPrograms *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDrivers:
		soap_serialize___ns1__GetDrivers(soap, (const struct __ns1__GetDrivers *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDevices:
		soap_serialize___ns1__GetDevices(soap, (const struct __ns1__GetDevices *)ptr);
		break;
	case SOAP_TYPE___ns1__GetBoardInfo:
		soap_serialize___ns1__GetBoardInfo(soap, (const struct __ns1__GetBoardInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__StopProgram:
		soap_serialize___ns1__StopProgram(soap, (const struct __ns1__StopProgram *)ptr);
		break;
	case SOAP_TYPE___ns1__StartProgram:
		soap_serialize___ns1__StartProgram(soap, (const struct __ns1__StartProgram *)ptr);
		break;
	case SOAP_TYPE___ns1__AddProgram:
		soap_serialize___ns1__AddProgram(soap, (const struct __ns1__AddProgram *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatusResponse:
		soap_serialize_PointerTo_ns1__GetRunningProgramsStatusResponse(soap, (_ns1__GetRunningProgramsStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatus:
		soap_serialize_PointerTo_ns1__GetRunningProgramsStatus(soap, (_ns1__GetRunningProgramsStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatusResponse:
		soap_serialize_PointerTo_ns1__GetProgramStatusResponse(soap, (_ns1__GetProgramStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProgramStatus:
		soap_serialize_PointerTo_ns1__GetProgramStatus(soap, (_ns1__GetProgramStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProgramResponse:
		soap_serialize_PointerTo_ns1__GetProgramResponse(soap, (_ns1__GetProgramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProgram:
		soap_serialize_PointerTo_ns1__GetProgram(soap, (_ns1__GetProgram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProgramsResponse:
		soap_serialize_PointerTo_ns1__GetProgramsResponse(soap, (_ns1__GetProgramsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPrograms:
		soap_serialize_PointerTo_ns1__GetPrograms(soap, (_ns1__GetPrograms *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDriversResponse:
		soap_serialize_PointerTo_ns1__GetDriversResponse(soap, (_ns1__GetDriversResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDrivers:
		soap_serialize_PointerTo_ns1__GetDrivers(soap, (_ns1__GetDrivers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDevicesResponse:
		soap_serialize_PointerTo_ns1__GetDevicesResponse(soap, (_ns1__GetDevicesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDevices:
		soap_serialize_PointerTo_ns1__GetDevices(soap, (_ns1__GetDevices *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfoResponse:
		soap_serialize_PointerTo_ns1__GetBoardInfoResponse(soap, (_ns1__GetBoardInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBoardInfo:
		soap_serialize_PointerTo_ns1__GetBoardInfo(soap, (_ns1__GetBoardInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopProgramResponse:
		soap_serialize_PointerTo_ns1__StopProgramResponse(soap, (_ns1__StopProgramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopProgram:
		soap_serialize_PointerTo_ns1__StopProgram(soap, (_ns1__StopProgram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartProgramResponse:
		soap_serialize_PointerTo_ns1__StartProgramResponse(soap, (_ns1__StartProgramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartProgram:
		soap_serialize_PointerTo_ns1__StartProgram(soap, (_ns1__StartProgram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddProgramResponse:
		soap_serialize_PointerTo_ns1__AddProgramResponse(soap, (_ns1__AddProgramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddProgram:
		soap_serialize_PointerTo_ns1__AddProgram(soap, (_ns1__AddProgram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapConnectionPointDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, (ns1__ArrayOfSoapConnectionPointDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireConnectionPointDescr:
		soap_serialize_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, (ns1__ArrayOfSoapWireConnectionPointDescr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventParameterDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, (ns1__ArrayOfSoapEventParameterDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandParameterDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, (ns1__ArrayOfSoapCommandParameterDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapEventDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapEventDescriptor(soap, (ns1__ArrayOfSoapEventDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapCommandDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapCommandDescriptor(soap, (ns1__ArrayOfSoapCommandDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPinoutDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, (ns1__ArrayOfSoapPinoutDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapWireDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapWireDescriptor(soap, (ns1__ArrayOfSoapWireDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapProgramDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapProgramDescriptor(soap, (ns1__ArrayOfSoapProgramDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDriverDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapDriverDescriptor(soap, (ns1__ArrayOfSoapDriverDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapDeviceDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, (ns1__ArrayOfSoapDeviceDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapProgramMappingDescriptor:
		soap_serialize_PointerTons1__SoapProgramMappingDescriptor(soap, (ns1__SoapProgramMappingDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapProgramDescriptor:
		soap_serialize_PointerTons1__SoapProgramDescriptor(soap, (ns1__SoapProgramDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapDriverDescriptor:
		soap_serialize_PointerTons1__SoapDriverDescriptor(soap, (ns1__SoapDriverDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapWireDescriptor:
		soap_serialize_PointerTons1__SoapWireDescriptor(soap, (ns1__SoapWireDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapDeviceDescriptor:
		soap_serialize_PointerTons1__SoapDeviceDescriptor(soap, (ns1__SoapDeviceDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapConnectionPointDescriptor:
		soap_serialize_PointerTons1__SoapConnectionPointDescriptor(soap, (ns1__SoapConnectionPointDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapWireConnectionPointDescr:
		soap_serialize_PointerTons1__SoapWireConnectionPointDescr(soap, (ns1__SoapWireConnectionPointDescr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapEventParameterDescriptor:
		soap_serialize_PointerTons1__SoapEventParameterDescriptor(soap, (ns1__SoapEventParameterDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapEventDescriptor:
		soap_serialize_PointerTons1__SoapEventDescriptor(soap, (ns1__SoapEventDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapCommandParameterDescriptor:
		soap_serialize_PointerTons1__SoapCommandParameterDescriptor(soap, (ns1__SoapCommandParameterDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapCommandDescriptor:
		soap_serialize_PointerTons1__SoapCommandDescriptor(soap, (ns1__SoapCommandDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapPinoutDescriptor:
		soap_serialize_PointerTons1__SoapPinoutDescriptor(soap, (ns1__SoapPinoutDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapPropertyDescriptor:
		soap_serialize_PointerTons1__SoapPropertyDescriptor(soap, (ns1__SoapPropertyDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSoapPropertyDescriptor:
		soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, (ns1__ArrayOfSoapPropertyDescriptor *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__SoapBaseObject:
		return (void*)soap_instantiate_ns1__SoapBaseObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapPropertyDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapPropertyDescriptor:
		return (void*)soap_instantiate_ns1__SoapPropertyDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapPinoutDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapCommandDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapCommandParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapEventDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapEventParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr:
		return (void*)soap_instantiate_ns1__ArrayOfSoapWireConnectionPointDescr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapConnectionPointDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapDeviceDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapWireDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapDriverDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor:
		return (void*)soap_instantiate_ns1__ArrayOfSoapProgramDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddProgram:
		return (void*)soap_instantiate__ns1__AddProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddProgramResponse:
		return (void*)soap_instantiate__ns1__AddProgramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartProgram:
		return (void*)soap_instantiate__ns1__StartProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartProgramResponse:
		return (void*)soap_instantiate__ns1__StartProgramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopProgram:
		return (void*)soap_instantiate__ns1__StopProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopProgramResponse:
		return (void*)soap_instantiate__ns1__StopProgramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBoardInfo:
		return (void*)soap_instantiate__ns1__GetBoardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBoardInfoResponse:
		return (void*)soap_instantiate__ns1__GetBoardInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevices:
		return (void*)soap_instantiate__ns1__GetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevicesResponse:
		return (void*)soap_instantiate__ns1__GetDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDrivers:
		return (void*)soap_instantiate__ns1__GetDrivers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDriversResponse:
		return (void*)soap_instantiate__ns1__GetDriversResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPrograms:
		return (void*)soap_instantiate__ns1__GetPrograms(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProgramsResponse:
		return (void*)soap_instantiate__ns1__GetProgramsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProgram:
		return (void*)soap_instantiate__ns1__GetProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProgramResponse:
		return (void*)soap_instantiate__ns1__GetProgramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProgramStatus:
		return (void*)soap_instantiate__ns1__GetProgramStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProgramStatusResponse:
		return (void*)soap_instantiate__ns1__GetProgramStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRunningProgramsStatus:
		return (void*)soap_instantiate__ns1__GetRunningProgramsStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRunningProgramsStatusResponse:
		return (void*)soap_instantiate__ns1__GetRunningProgramsStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapProgramDescriptor:
		return (void*)soap_instantiate_ns1__SoapProgramDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapProgramMappingDescriptor:
		return (void*)soap_instantiate_ns1__SoapProgramMappingDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapPinoutDescriptor:
		return (void*)soap_instantiate_ns1__SoapPinoutDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapCommandDescriptor:
		return (void*)soap_instantiate_ns1__SoapCommandDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapCommandParameterDescriptor:
		return (void*)soap_instantiate_ns1__SoapCommandParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapEventDescriptor:
		return (void*)soap_instantiate_ns1__SoapEventDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapEventParameterDescriptor:
		return (void*)soap_instantiate_ns1__SoapEventParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapWireConnectionPointDescr:
		return (void*)soap_instantiate_ns1__SoapWireConnectionPointDescr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapWireDescriptor:
		return (void*)soap_instantiate_ns1__SoapWireDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapConnectionPointDescriptor:
		return (void*)soap_instantiate_ns1__SoapConnectionPointDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapDeviceDescriptor:
		return (void*)soap_instantiate_ns1__SoapDeviceDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapDriverDescriptor:
		return (void*)soap_instantiate_ns1__SoapDriverDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AddProgram:
		return (void*)soap_instantiate___ns1__AddProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__StartProgram:
		return (void*)soap_instantiate___ns1__StartProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__StopProgram:
		return (void*)soap_instantiate___ns1__StopProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBoardInfo:
		return (void*)soap_instantiate___ns1__GetBoardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDevices:
		return (void*)soap_instantiate___ns1__GetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDrivers:
		return (void*)soap_instantiate___ns1__GetDrivers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPrograms:
		return (void*)soap_instantiate___ns1__GetPrograms(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetProgram:
		return (void*)soap_instantiate___ns1__GetProgram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetProgramStatus:
		return (void*)soap_instantiate___ns1__GetProgramStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRunningProgramsStatus:
		return (void*)soap_instantiate___ns1__GetRunningProgramsStatus(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__SoapBaseObject:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapBaseObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapBaseObject*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapPropertyDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapPropertyDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapPropertyDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapPropertyDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapPropertyDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapPinoutDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapPinoutDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapCommandDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapCommandDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapCommandParameterDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapCommandParameterDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapEventDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapEventDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapEventParameterDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapEventParameterDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapWireConnectionPointDescr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapWireConnectionPointDescr*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapConnectionPointDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapConnectionPointDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapDeviceDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapDeviceDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapWireDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapWireDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapDriverDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapDriverDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfSoapProgramDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfSoapProgramDescriptor*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddProgram:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddProgram*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AddProgramResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AddProgramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AddProgramResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StartProgram:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StartProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StartProgram*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StartProgramResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StartProgramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StartProgramResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StopProgram:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StopProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StopProgram*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StopProgramResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StopProgramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StopProgramResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBoardInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBoardInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBoardInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBoardInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBoardInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBoardInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDevices:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDevices*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDevices*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDevicesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDevicesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDevicesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDrivers:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDrivers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDrivers*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDriversResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDriversResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDriversResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPrograms:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPrograms*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPrograms*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetProgramsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetProgramsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetProgramsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetProgram:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetProgram*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetProgramResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetProgramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetProgramResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetProgramStatus:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetProgramStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetProgramStatus*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetProgramStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetProgramStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetProgramStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetRunningProgramsStatus:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetRunningProgramsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetRunningProgramsStatus*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetRunningProgramsStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetRunningProgramsStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetRunningProgramsStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapProgramDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapProgramDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapProgramDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapProgramMappingDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapProgramMappingDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapProgramMappingDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapPinoutDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapPinoutDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapPinoutDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapCommandDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapCommandDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapCommandDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapCommandParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapCommandParameterDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapCommandParameterDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapEventDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapEventDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapEventDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapEventParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapEventParameterDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapEventParameterDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapWireConnectionPointDescr:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapWireConnectionPointDescr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapWireConnectionPointDescr*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapWireDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapWireDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapWireDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapConnectionPointDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapConnectionPointDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapConnectionPointDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapDeviceDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapDeviceDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapDeviceDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SoapDriverDescriptor:
		if (p->size < 0)
			SOAP_DELETE((ns1__SoapDriverDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SoapDriverDescriptor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__AddProgram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__AddProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__AddProgram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__StartProgram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StartProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StartProgram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__StopProgram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StopProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StopProgram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBoardInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetBoardInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetBoardInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetDevices:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetDevices*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetDevices*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetDrivers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetDrivers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetDrivers*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPrograms:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPrograms*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPrograms*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetProgram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetProgram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetProgram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetProgramStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetProgramStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetProgramStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRunningProgramsStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRunningProgramsStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRunningProgramsStatus*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapProgramDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapProgramDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapDriverDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapDriverDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapWireDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapWireDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapDeviceDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapDeviceDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapConnectionPointDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapConnectionPointDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapWireConnectionPointDescr * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapWireConnectionPointDescr * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapEventParameterDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapEventParameterDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapEventDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapEventDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapCommandParameterDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapCommandParameterDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapCommandDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapCommandDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapPinoutDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapPinoutDescriptor * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__SoapPropertyDescriptor * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__SoapPropertyDescriptor * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapProgramDescriptor * >*)p)[len] = *(ns1__SoapProgramDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapDriverDescriptor * >*)p)[len] = *(ns1__SoapDriverDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapWireDescriptor * >*)p)[len] = *(ns1__SoapWireDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapDeviceDescriptor * >*)p)[len] = *(ns1__SoapDeviceDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapConnectionPointDescriptor * >*)p)[len] = *(ns1__SoapConnectionPointDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapWireConnectionPointDescr * >*)p)[len] = *(ns1__SoapWireConnectionPointDescr **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapEventParameterDescriptor * >*)p)[len] = *(ns1__SoapEventParameterDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapEventDescriptor * >*)p)[len] = *(ns1__SoapEventDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapCommandParameterDescriptor * >*)p)[len] = *(ns1__SoapCommandParameterDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapCommandDescriptor * >*)p)[len] = *(ns1__SoapCommandDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapPinoutDescriptor * >*)p)[len] = *(ns1__SoapPinoutDescriptor **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SoapPropertyDescriptor * >*)p)[len] = *(ns1__SoapPropertyDescriptor **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__GetRunningProgramsStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRunningProgramsStatusResponse::GetRunningProgramsStatusResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetRunningProgramsStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapProgramDescriptor(soap, &this->_ns1__GetRunningProgramsStatusResponse::GetRunningProgramsStatusResult);
	/* transient soap skipped */
}

int _ns1__GetRunningProgramsStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRunningProgramsStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRunningProgramsStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRunningProgramsStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse), type))
		return soap->error;
	if (a->GetRunningProgramsStatusResult)
		soap_element_result(soap, "ns1:GetRunningProgramsStatusResult");
	if (soap_out_PointerTons1__ArrayOfSoapProgramDescriptor(soap, "ns1:GetRunningProgramsStatusResult", -1, &(a->_ns1__GetRunningProgramsStatusResponse::GetRunningProgramsStatusResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRunningProgramsStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRunningProgramsStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatusResponse * SOAP_FMAC4 soap_in__ns1__GetRunningProgramsStatusResponse(struct soap *soap, const char *tag, _ns1__GetRunningProgramsStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRunningProgramsStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse, sizeof(_ns1__GetRunningProgramsStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetRunningProgramsStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetRunningProgramsStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetRunningProgramsStatusResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRunningProgramsStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapProgramDescriptor(soap, "ns1:GetRunningProgramsStatusResult", &(a->_ns1__GetRunningProgramsStatusResponse::GetRunningProgramsStatusResult), "ns1:ArrayOfSoapProgramDescriptor"))
				{	soap_flag_GetRunningProgramsStatusResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetRunningProgramsStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRunningProgramsStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse, 0, sizeof(_ns1__GetRunningProgramsStatusResponse), 0, soap_copy__ns1__GetRunningProgramsStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetRunningProgramsStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetRunningProgramsStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRunningProgramsStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRunningProgramsStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatusResponse * SOAP_FMAC4 soap_get__ns1__GetRunningProgramsStatusResponse(struct soap *soap, _ns1__GetRunningProgramsStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRunningProgramsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetRunningProgramsStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRunningProgramsStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRunningProgramsStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRunningProgramsStatusResponse);
		if (size)
			*size = sizeof(_ns1__GetRunningProgramsStatusResponse);
		((_ns1__GetRunningProgramsStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRunningProgramsStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetRunningProgramsStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetRunningProgramsStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetRunningProgramsStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetRunningProgramsStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetRunningProgramsStatusResponse %p -> %p\n", q, p));
	*(_ns1__GetRunningProgramsStatusResponse*)p = *(_ns1__GetRunningProgramsStatusResponse*)q;
}

void _ns1__GetRunningProgramsStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetRunningProgramsStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetRunningProgramsStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRunningProgramsStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, int id, const _ns1__GetRunningProgramsStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRunningProgramsStatus), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRunningProgramsStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRunningProgramsStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatus * SOAP_FMAC4 soap_in__ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, _ns1__GetRunningProgramsStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRunningProgramsStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRunningProgramsStatus, sizeof(_ns1__GetRunningProgramsStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetRunningProgramsStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetRunningProgramsStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRunningProgramsStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRunningProgramsStatus, 0, sizeof(_ns1__GetRunningProgramsStatus), 0, soap_copy__ns1__GetRunningProgramsStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetRunningProgramsStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetRunningProgramsStatus);
	if (this->soap_out(soap, tag?tag:"ns1:GetRunningProgramsStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRunningProgramsStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRunningProgramsStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatus * SOAP_FMAC4 soap_get__ns1__GetRunningProgramsStatus(struct soap *soap, _ns1__GetRunningProgramsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRunningProgramsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetRunningProgramsStatus * SOAP_FMAC2 soap_instantiate__ns1__GetRunningProgramsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRunningProgramsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetRunningProgramsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRunningProgramsStatus);
		if (size)
			*size = sizeof(_ns1__GetRunningProgramsStatus);
		((_ns1__GetRunningProgramsStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRunningProgramsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetRunningProgramsStatus);
		for (int i = 0; i < n; i++)
			((_ns1__GetRunningProgramsStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetRunningProgramsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetRunningProgramsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetRunningProgramsStatus %p -> %p\n", q, p));
	*(_ns1__GetRunningProgramsStatus*)p = *(_ns1__GetRunningProgramsStatus*)q;
}

void _ns1__GetProgramStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetProgramStatusResponse::GetProgramStatusResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetProgramStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SoapProgramDescriptor(soap, &this->_ns1__GetProgramStatusResponse::GetProgramStatusResult);
	/* transient soap skipped */
}

int _ns1__GetProgramStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProgramStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProgramStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__GetProgramStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProgramStatusResponse), type))
		return soap->error;
	if (a->GetProgramStatusResult)
		soap_element_result(soap, "ns1:GetProgramStatusResult");
	if (soap_out_PointerTons1__SoapProgramDescriptor(soap, "ns1:GetProgramStatusResult", -1, &(a->_ns1__GetProgramStatusResponse::GetProgramStatusResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetProgramStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProgramStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProgramStatusResponse * SOAP_FMAC4 soap_in__ns1__GetProgramStatusResponse(struct soap *soap, const char *tag, _ns1__GetProgramStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProgramStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProgramStatusResponse, sizeof(_ns1__GetProgramStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProgramStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProgramStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetProgramStatusResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetProgramStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapProgramDescriptor(soap, "ns1:GetProgramStatusResult", &(a->_ns1__GetProgramStatusResponse::GetProgramStatusResult), "ns1:SoapProgramDescriptor"))
				{	soap_flag_GetProgramStatusResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetProgramStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProgramStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProgramStatusResponse, 0, sizeof(_ns1__GetProgramStatusResponse), 0, soap_copy__ns1__GetProgramStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetProgramStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProgramStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetProgramStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetProgramStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProgramStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProgramStatusResponse * SOAP_FMAC4 soap_get__ns1__GetProgramStatusResponse(struct soap *soap, _ns1__GetProgramStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProgramStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetProgramStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetProgramStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProgramStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProgramStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramStatusResponse);
		if (size)
			*size = sizeof(_ns1__GetProgramStatusResponse);
		((_ns1__GetProgramStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProgramStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetProgramStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProgramStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProgramStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProgramStatusResponse %p -> %p\n", q, p));
	*(_ns1__GetProgramStatusResponse*)p = *(_ns1__GetProgramStatusResponse*)q;
}

void _ns1__GetProgramStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetProgramStatus::programName = NULL;
	/* transient soap skipped */
}

void _ns1__GetProgramStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetProgramStatus::programName);
	/* transient soap skipped */
}

int _ns1__GetProgramStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProgramStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProgramStatus(struct soap *soap, const char *tag, int id, const _ns1__GetProgramStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProgramStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:programName", -1, &(a->_ns1__GetProgramStatus::programName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetProgramStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProgramStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProgramStatus * SOAP_FMAC4 soap_in__ns1__GetProgramStatus(struct soap *soap, const char *tag, _ns1__GetProgramStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProgramStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProgramStatus, sizeof(_ns1__GetProgramStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProgramStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProgramStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_programName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:programName", &(a->_ns1__GetProgramStatus::programName), "xsd:string"))
				{	soap_flag_programName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProgramStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProgramStatus, 0, sizeof(_ns1__GetProgramStatus), 0, soap_copy__ns1__GetProgramStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetProgramStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProgramStatus);
	if (this->soap_out(soap, tag?tag:"ns1:GetProgramStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetProgramStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProgramStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProgramStatus * SOAP_FMAC4 soap_get__ns1__GetProgramStatus(struct soap *soap, _ns1__GetProgramStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProgramStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetProgramStatus * SOAP_FMAC2 soap_instantiate__ns1__GetProgramStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProgramStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProgramStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramStatus);
		if (size)
			*size = sizeof(_ns1__GetProgramStatus);
		((_ns1__GetProgramStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProgramStatus);
		for (int i = 0; i < n; i++)
			((_ns1__GetProgramStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProgramStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProgramStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProgramStatus %p -> %p\n", q, p));
	*(_ns1__GetProgramStatus*)p = *(_ns1__GetProgramStatus*)q;
}

void _ns1__GetProgramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetProgramResponse::GetProgramResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetProgramResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SoapProgramDescriptor(soap, &this->_ns1__GetProgramResponse::GetProgramResult);
	/* transient soap skipped */
}

int _ns1__GetProgramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProgramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProgramResponse(struct soap *soap, const char *tag, int id, const _ns1__GetProgramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProgramResponse), type))
		return soap->error;
	if (a->GetProgramResult)
		soap_element_result(soap, "ns1:GetProgramResult");
	if (soap_out_PointerTons1__SoapProgramDescriptor(soap, "ns1:GetProgramResult", -1, &(a->_ns1__GetProgramResponse::GetProgramResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetProgramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProgramResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProgramResponse * SOAP_FMAC4 soap_in__ns1__GetProgramResponse(struct soap *soap, const char *tag, _ns1__GetProgramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProgramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProgramResponse, sizeof(_ns1__GetProgramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProgramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProgramResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetProgramResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetProgramResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapProgramDescriptor(soap, "ns1:GetProgramResult", &(a->_ns1__GetProgramResponse::GetProgramResult), "ns1:SoapProgramDescriptor"))
				{	soap_flag_GetProgramResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetProgramResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProgramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProgramResponse, 0, sizeof(_ns1__GetProgramResponse), 0, soap_copy__ns1__GetProgramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetProgramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProgramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetProgramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetProgramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProgramResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProgramResponse * SOAP_FMAC4 soap_get__ns1__GetProgramResponse(struct soap *soap, _ns1__GetProgramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetProgramResponse * SOAP_FMAC2 soap_instantiate__ns1__GetProgramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProgramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProgramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramResponse);
		if (size)
			*size = sizeof(_ns1__GetProgramResponse);
		((_ns1__GetProgramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProgramResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetProgramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProgramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProgramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProgramResponse %p -> %p\n", q, p));
	*(_ns1__GetProgramResponse*)p = *(_ns1__GetProgramResponse*)q;
}

void _ns1__GetProgram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetProgram::programName = NULL;
	/* transient soap skipped */
}

void _ns1__GetProgram::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetProgram::programName);
	/* transient soap skipped */
}

int _ns1__GetProgram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProgram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProgram(struct soap *soap, const char *tag, int id, const _ns1__GetProgram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProgram), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:programName", -1, &(a->_ns1__GetProgram::programName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetProgram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProgram(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProgram * SOAP_FMAC4 soap_in__ns1__GetProgram(struct soap *soap, const char *tag, _ns1__GetProgram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProgram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProgram, sizeof(_ns1__GetProgram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProgram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProgram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_programName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:programName", &(a->_ns1__GetProgram::programName), "xsd:string"))
				{	soap_flag_programName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProgram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProgram, 0, sizeof(_ns1__GetProgram), 0, soap_copy__ns1__GetProgram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetProgram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProgram);
	if (this->soap_out(soap, tag?tag:"ns1:GetProgram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetProgram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProgram(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProgram * SOAP_FMAC4 soap_get__ns1__GetProgram(struct soap *soap, _ns1__GetProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetProgram * SOAP_FMAC2 soap_instantiate__ns1__GetProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgram);
		if (size)
			*size = sizeof(_ns1__GetProgram);
		((_ns1__GetProgram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProgram);
		for (int i = 0; i < n; i++)
			((_ns1__GetProgram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProgram %p -> %p\n", q, p));
	*(_ns1__GetProgram*)p = *(_ns1__GetProgram*)q;
}

void _ns1__GetProgramsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetProgramsResponse::GetProgramsResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetProgramsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapProgramDescriptor(soap, &this->_ns1__GetProgramsResponse::GetProgramsResult);
	/* transient soap skipped */
}

int _ns1__GetProgramsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProgramsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProgramsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetProgramsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProgramsResponse), type))
		return soap->error;
	if (a->GetProgramsResult)
		soap_element_result(soap, "ns1:GetProgramsResult");
	if (soap_out_PointerTons1__ArrayOfSoapProgramDescriptor(soap, "ns1:GetProgramsResult", -1, &(a->_ns1__GetProgramsResponse::GetProgramsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetProgramsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProgramsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProgramsResponse * SOAP_FMAC4 soap_in__ns1__GetProgramsResponse(struct soap *soap, const char *tag, _ns1__GetProgramsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProgramsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProgramsResponse, sizeof(_ns1__GetProgramsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProgramsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProgramsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetProgramsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetProgramsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapProgramDescriptor(soap, "ns1:GetProgramsResult", &(a->_ns1__GetProgramsResponse::GetProgramsResult), "ns1:ArrayOfSoapProgramDescriptor"))
				{	soap_flag_GetProgramsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetProgramsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProgramsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProgramsResponse, 0, sizeof(_ns1__GetProgramsResponse), 0, soap_copy__ns1__GetProgramsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetProgramsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProgramsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetProgramsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetProgramsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProgramsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProgramsResponse * SOAP_FMAC4 soap_get__ns1__GetProgramsResponse(struct soap *soap, _ns1__GetProgramsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProgramsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetProgramsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetProgramsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProgramsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProgramsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramsResponse);
		if (size)
			*size = sizeof(_ns1__GetProgramsResponse);
		((_ns1__GetProgramsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetProgramsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProgramsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetProgramsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProgramsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProgramsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProgramsResponse %p -> %p\n", q, p));
	*(_ns1__GetProgramsResponse*)p = *(_ns1__GetProgramsResponse*)q;
}

void _ns1__GetPrograms::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetPrograms::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPrograms::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPrograms(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPrograms(struct soap *soap, const char *tag, int id, const _ns1__GetPrograms *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPrograms), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPrograms::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPrograms(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPrograms * SOAP_FMAC4 soap_in__ns1__GetPrograms(struct soap *soap, const char *tag, _ns1__GetPrograms *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPrograms *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPrograms, sizeof(_ns1__GetPrograms), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPrograms)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPrograms *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPrograms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPrograms, 0, sizeof(_ns1__GetPrograms), 0, soap_copy__ns1__GetPrograms);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPrograms::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPrograms);
	if (this->soap_out(soap, tag?tag:"ns1:GetPrograms", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPrograms::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPrograms(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPrograms * SOAP_FMAC4 soap_get__ns1__GetPrograms(struct soap *soap, _ns1__GetPrograms *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPrograms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPrograms * SOAP_FMAC2 soap_instantiate__ns1__GetPrograms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPrograms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPrograms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPrograms);
		if (size)
			*size = sizeof(_ns1__GetPrograms);
		((_ns1__GetPrograms*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPrograms[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPrograms);
		for (int i = 0; i < n; i++)
			((_ns1__GetPrograms*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPrograms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPrograms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPrograms %p -> %p\n", q, p));
	*(_ns1__GetPrograms*)p = *(_ns1__GetPrograms*)q;
}

void _ns1__GetDriversResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDriversResponse::GetDriversResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDriversResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapDriverDescriptor(soap, &this->_ns1__GetDriversResponse::GetDriversResult);
	/* transient soap skipped */
}

int _ns1__GetDriversResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDriversResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDriversResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDriversResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDriversResponse), type))
		return soap->error;
	if (a->GetDriversResult)
		soap_element_result(soap, "ns1:GetDriversResult");
	if (soap_out_PointerTons1__ArrayOfSoapDriverDescriptor(soap, "ns1:GetDriversResult", -1, &(a->_ns1__GetDriversResponse::GetDriversResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDriversResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDriversResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDriversResponse * SOAP_FMAC4 soap_in__ns1__GetDriversResponse(struct soap *soap, const char *tag, _ns1__GetDriversResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDriversResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDriversResponse, sizeof(_ns1__GetDriversResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDriversResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDriversResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetDriversResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDriversResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapDriverDescriptor(soap, "ns1:GetDriversResult", &(a->_ns1__GetDriversResponse::GetDriversResult), "ns1:ArrayOfSoapDriverDescriptor"))
				{	soap_flag_GetDriversResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetDriversResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDriversResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDriversResponse, 0, sizeof(_ns1__GetDriversResponse), 0, soap_copy__ns1__GetDriversResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDriversResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDriversResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetDriversResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDriversResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDriversResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDriversResponse * SOAP_FMAC4 soap_get__ns1__GetDriversResponse(struct soap *soap, _ns1__GetDriversResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDriversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDriversResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDriversResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDriversResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDriversResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDriversResponse);
		if (size)
			*size = sizeof(_ns1__GetDriversResponse);
		((_ns1__GetDriversResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDriversResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDriversResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetDriversResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDriversResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDriversResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDriversResponse %p -> %p\n", q, p));
	*(_ns1__GetDriversResponse*)p = *(_ns1__GetDriversResponse*)q;
}

void _ns1__GetDrivers::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetDrivers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetDrivers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDrivers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDrivers(struct soap *soap, const char *tag, int id, const _ns1__GetDrivers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDrivers), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDrivers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDrivers(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDrivers * SOAP_FMAC4 soap_in__ns1__GetDrivers(struct soap *soap, const char *tag, _ns1__GetDrivers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDrivers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDrivers, sizeof(_ns1__GetDrivers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDrivers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDrivers *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDrivers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDrivers, 0, sizeof(_ns1__GetDrivers), 0, soap_copy__ns1__GetDrivers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDrivers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDrivers);
	if (this->soap_out(soap, tag?tag:"ns1:GetDrivers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDrivers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDrivers(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDrivers * SOAP_FMAC4 soap_get__ns1__GetDrivers(struct soap *soap, _ns1__GetDrivers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDrivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDrivers * SOAP_FMAC2 soap_instantiate__ns1__GetDrivers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDrivers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDrivers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDrivers);
		if (size)
			*size = sizeof(_ns1__GetDrivers);
		((_ns1__GetDrivers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDrivers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDrivers);
		for (int i = 0; i < n; i++)
			((_ns1__GetDrivers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDrivers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDrivers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDrivers %p -> %p\n", q, p));
	*(_ns1__GetDrivers*)p = *(_ns1__GetDrivers*)q;
}

void _ns1__GetDevicesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDevicesResponse::GetDevicesResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDevicesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, &this->_ns1__GetDevicesResponse::GetDevicesResult);
	/* transient soap skipped */
}

int _ns1__GetDevicesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevicesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevicesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevicesResponse), type))
		return soap->error;
	if (a->GetDevicesResult)
		soap_element_result(soap, "ns1:GetDevicesResult");
	if (soap_out_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, "ns1:GetDevicesResult", -1, &(a->_ns1__GetDevicesResponse::GetDevicesResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevicesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevicesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevicesResponse * SOAP_FMAC4 soap_in__ns1__GetDevicesResponse(struct soap *soap, const char *tag, _ns1__GetDevicesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevicesResponse, sizeof(_ns1__GetDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDevicesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDevicesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetDevicesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDevicesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, "ns1:GetDevicesResult", &(a->_ns1__GetDevicesResponse::GetDevicesResult), "ns1:ArrayOfSoapDeviceDescriptor"))
				{	soap_flag_GetDevicesResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetDevicesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevicesResponse, 0, sizeof(_ns1__GetDevicesResponse), 0, soap_copy__ns1__GetDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDevicesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDevicesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetDevicesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevicesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevicesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevicesResponse * SOAP_FMAC4 soap_get__ns1__GetDevicesResponse(struct soap *soap, _ns1__GetDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDevicesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDevicesResponse);
		if (size)
			*size = sizeof(_ns1__GetDevicesResponse);
		((_ns1__GetDevicesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDevicesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDevicesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetDevicesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDevicesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDevicesResponse %p -> %p\n", q, p));
	*(_ns1__GetDevicesResponse*)p = *(_ns1__GetDevicesResponse*)q;
}

void _ns1__GetDevices::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetDevices::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetDevices::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevices(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevices(struct soap *soap, const char *tag, int id, const _ns1__GetDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevices), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevices::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevices(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevices * SOAP_FMAC4 soap_in__ns1__GetDevices(struct soap *soap, const char *tag, _ns1__GetDevices *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevices *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevices, sizeof(_ns1__GetDevices), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDevices)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDevices *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevices, 0, sizeof(_ns1__GetDevices), 0, soap_copy__ns1__GetDevices);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDevices::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDevices);
	if (this->soap_out(soap, tag?tag:"ns1:GetDevices", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevices::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevices(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevices * SOAP_FMAC4 soap_get__ns1__GetDevices(struct soap *soap, _ns1__GetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDevices * SOAP_FMAC2 soap_instantiate__ns1__GetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDevices);
		if (size)
			*size = sizeof(_ns1__GetDevices);
		((_ns1__GetDevices*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDevices[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDevices);
		for (int i = 0; i < n; i++)
			((_ns1__GetDevices*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDevices*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDevices %p -> %p\n", q, p));
	*(_ns1__GetDevices*)p = *(_ns1__GetDevices*)q;
}

void _ns1__GetBoardInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetBoardInfoResponse::GetBoardInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetBoardInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->_ns1__GetBoardInfoResponse::GetBoardInfoResult);
	/* transient soap skipped */
}

int _ns1__GetBoardInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBoardInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBoardInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetBoardInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBoardInfoResponse), type))
		return soap->error;
	if (a->GetBoardInfoResult)
		soap_element_result(soap, "ns1:GetBoardInfoResult");
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:GetBoardInfoResult", -1, &(a->_ns1__GetBoardInfoResponse::GetBoardInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBoardInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBoardInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBoardInfoResponse * SOAP_FMAC4 soap_in__ns1__GetBoardInfoResponse(struct soap *soap, const char *tag, _ns1__GetBoardInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBoardInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBoardInfoResponse, sizeof(_ns1__GetBoardInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBoardInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBoardInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetBoardInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBoardInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:GetBoardInfoResult", &(a->_ns1__GetBoardInfoResponse::GetBoardInfoResult), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_GetBoardInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetBoardInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBoardInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBoardInfoResponse, 0, sizeof(_ns1__GetBoardInfoResponse), 0, soap_copy__ns1__GetBoardInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetBoardInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBoardInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetBoardInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBoardInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBoardInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBoardInfoResponse * SOAP_FMAC4 soap_get__ns1__GetBoardInfoResponse(struct soap *soap, _ns1__GetBoardInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBoardInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBoardInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetBoardInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBoardInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBoardInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBoardInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetBoardInfoResponse);
		((_ns1__GetBoardInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBoardInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBoardInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetBoardInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBoardInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBoardInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBoardInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetBoardInfoResponse*)p = *(_ns1__GetBoardInfoResponse*)q;
}

void _ns1__GetBoardInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetBoardInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetBoardInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBoardInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBoardInfo(struct soap *soap, const char *tag, int id, const _ns1__GetBoardInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBoardInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBoardInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBoardInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBoardInfo * SOAP_FMAC4 soap_in__ns1__GetBoardInfo(struct soap *soap, const char *tag, _ns1__GetBoardInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBoardInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBoardInfo, sizeof(_ns1__GetBoardInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBoardInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBoardInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBoardInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBoardInfo, 0, sizeof(_ns1__GetBoardInfo), 0, soap_copy__ns1__GetBoardInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetBoardInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBoardInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetBoardInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBoardInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBoardInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBoardInfo * SOAP_FMAC4 soap_get__ns1__GetBoardInfo(struct soap *soap, _ns1__GetBoardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBoardInfo * SOAP_FMAC2 soap_instantiate__ns1__GetBoardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBoardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBoardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBoardInfo);
		if (size)
			*size = sizeof(_ns1__GetBoardInfo);
		((_ns1__GetBoardInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBoardInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBoardInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetBoardInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBoardInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBoardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBoardInfo %p -> %p\n", q, p));
	*(_ns1__GetBoardInfo*)p = *(_ns1__GetBoardInfo*)q;
}

void _ns1__StopProgramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__StopProgramResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopProgramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopProgramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopProgramResponse(struct soap *soap, const char *tag, int id, const _ns1__StopProgramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopProgramResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopProgramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopProgramResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopProgramResponse * SOAP_FMAC4 soap_in__ns1__StopProgramResponse(struct soap *soap, const char *tag, _ns1__StopProgramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopProgramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopProgramResponse, sizeof(_ns1__StopProgramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopProgramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopProgramResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopProgramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopProgramResponse, 0, sizeof(_ns1__StopProgramResponse), 0, soap_copy__ns1__StopProgramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__StopProgramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopProgramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:StopProgramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopProgramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopProgramResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopProgramResponse * SOAP_FMAC4 soap_get__ns1__StopProgramResponse(struct soap *soap, _ns1__StopProgramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StopProgramResponse * SOAP_FMAC2 soap_instantiate__ns1__StopProgramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopProgramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopProgramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopProgramResponse);
		if (size)
			*size = sizeof(_ns1__StopProgramResponse);
		((_ns1__StopProgramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopProgramResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopProgramResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StopProgramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopProgramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopProgramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopProgramResponse %p -> %p\n", q, p));
	*(_ns1__StopProgramResponse*)p = *(_ns1__StopProgramResponse*)q;
}

void _ns1__StopProgram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__StopProgram::programName = NULL;
	/* transient soap skipped */
}

void _ns1__StopProgram::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__StopProgram::programName);
	/* transient soap skipped */
}

int _ns1__StopProgram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopProgram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopProgram(struct soap *soap, const char *tag, int id, const _ns1__StopProgram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopProgram), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:programName", -1, &(a->_ns1__StopProgram::programName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopProgram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopProgram(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopProgram * SOAP_FMAC4 soap_in__ns1__StopProgram(struct soap *soap, const char *tag, _ns1__StopProgram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopProgram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopProgram, sizeof(_ns1__StopProgram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopProgram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopProgram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_programName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:programName", &(a->_ns1__StopProgram::programName), "xsd:string"))
				{	soap_flag_programName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopProgram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopProgram, 0, sizeof(_ns1__StopProgram), 0, soap_copy__ns1__StopProgram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__StopProgram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopProgram);
	if (this->soap_out(soap, tag?tag:"ns1:StopProgram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopProgram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopProgram(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopProgram * SOAP_FMAC4 soap_get__ns1__StopProgram(struct soap *soap, _ns1__StopProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StopProgram * SOAP_FMAC2 soap_instantiate__ns1__StopProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopProgram);
		if (size)
			*size = sizeof(_ns1__StopProgram);
		((_ns1__StopProgram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopProgram);
		for (int i = 0; i < n; i++)
			((_ns1__StopProgram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopProgram %p -> %p\n", q, p));
	*(_ns1__StopProgram*)p = *(_ns1__StopProgram*)q;
}

void _ns1__StartProgramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__StartProgramResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StartProgramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartProgramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartProgramResponse(struct soap *soap, const char *tag, int id, const _ns1__StartProgramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartProgramResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartProgramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartProgramResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartProgramResponse * SOAP_FMAC4 soap_in__ns1__StartProgramResponse(struct soap *soap, const char *tag, _ns1__StartProgramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartProgramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartProgramResponse, sizeof(_ns1__StartProgramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StartProgramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StartProgramResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StartProgramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartProgramResponse, 0, sizeof(_ns1__StartProgramResponse), 0, soap_copy__ns1__StartProgramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__StartProgramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StartProgramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:StartProgramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartProgramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartProgramResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartProgramResponse * SOAP_FMAC4 soap_get__ns1__StartProgramResponse(struct soap *soap, _ns1__StartProgramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StartProgramResponse * SOAP_FMAC2 soap_instantiate__ns1__StartProgramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartProgramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StartProgramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StartProgramResponse);
		if (size)
			*size = sizeof(_ns1__StartProgramResponse);
		((_ns1__StartProgramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StartProgramResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StartProgramResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StartProgramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StartProgramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StartProgramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StartProgramResponse %p -> %p\n", q, p));
	*(_ns1__StartProgramResponse*)p = *(_ns1__StartProgramResponse*)q;
}

void _ns1__StartProgram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__StartProgram::programName = NULL;
	/* transient soap skipped */
}

void _ns1__StartProgram::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__StartProgram::programName);
	/* transient soap skipped */
}

int _ns1__StartProgram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartProgram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartProgram(struct soap *soap, const char *tag, int id, const _ns1__StartProgram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartProgram), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:programName", -1, &(a->_ns1__StartProgram::programName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartProgram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartProgram(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartProgram * SOAP_FMAC4 soap_in__ns1__StartProgram(struct soap *soap, const char *tag, _ns1__StartProgram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartProgram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartProgram, sizeof(_ns1__StartProgram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StartProgram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StartProgram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_programName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:programName", &(a->_ns1__StartProgram::programName), "xsd:string"))
				{	soap_flag_programName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StartProgram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartProgram, 0, sizeof(_ns1__StartProgram), 0, soap_copy__ns1__StartProgram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__StartProgram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StartProgram);
	if (this->soap_out(soap, tag?tag:"ns1:StartProgram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartProgram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartProgram(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartProgram * SOAP_FMAC4 soap_get__ns1__StartProgram(struct soap *soap, _ns1__StartProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StartProgram * SOAP_FMAC2 soap_instantiate__ns1__StartProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StartProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StartProgram);
		if (size)
			*size = sizeof(_ns1__StartProgram);
		((_ns1__StartProgram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StartProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StartProgram);
		for (int i = 0; i < n; i++)
			((_ns1__StartProgram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StartProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StartProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StartProgram %p -> %p\n", q, p));
	*(_ns1__StartProgram*)p = *(_ns1__StartProgram*)q;
}

void _ns1__AddProgramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__AddProgramResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__AddProgramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddProgramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddProgramResponse(struct soap *soap, const char *tag, int id, const _ns1__AddProgramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddProgramResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddProgramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddProgramResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddProgramResponse * SOAP_FMAC4 soap_in__ns1__AddProgramResponse(struct soap *soap, const char *tag, _ns1__AddProgramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddProgramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddProgramResponse, sizeof(_ns1__AddProgramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddProgramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddProgramResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddProgramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddProgramResponse, 0, sizeof(_ns1__AddProgramResponse), 0, soap_copy__ns1__AddProgramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddProgramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddProgramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AddProgramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddProgramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddProgramResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddProgramResponse * SOAP_FMAC4 soap_get__ns1__AddProgramResponse(struct soap *soap, _ns1__AddProgramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddProgramResponse * SOAP_FMAC2 soap_instantiate__ns1__AddProgramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddProgramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddProgramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddProgramResponse);
		if (size)
			*size = sizeof(_ns1__AddProgramResponse);
		((_ns1__AddProgramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddProgramResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddProgramResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddProgramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddProgramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddProgramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddProgramResponse %p -> %p\n", q, p));
	*(_ns1__AddProgramResponse*)p = *(_ns1__AddProgramResponse*)q;
}

void _ns1__AddProgram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AddProgram::program = NULL;
	this->_ns1__AddProgram::mapping = NULL;
	/* transient soap skipped */
}

void _ns1__AddProgram::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SoapProgramDescriptor(soap, &this->_ns1__AddProgram::program);
	soap_serialize_PointerTons1__SoapProgramMappingDescriptor(soap, &this->_ns1__AddProgram::mapping);
	/* transient soap skipped */
}

int _ns1__AddProgram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddProgram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddProgram(struct soap *soap, const char *tag, int id, const _ns1__AddProgram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddProgram), type))
		return soap->error;
	if (soap_out_PointerTons1__SoapProgramDescriptor(soap, "ns1:program", -1, &(a->_ns1__AddProgram::program), ""))
		return soap->error;
	if (soap_out_PointerTons1__SoapProgramMappingDescriptor(soap, "ns1:mapping", -1, &(a->_ns1__AddProgram::mapping), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddProgram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddProgram(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddProgram * SOAP_FMAC4 soap_in__ns1__AddProgram(struct soap *soap, const char *tag, _ns1__AddProgram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddProgram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddProgram, sizeof(_ns1__AddProgram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddProgram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddProgram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_program1 = 1;
	size_t soap_flag_mapping1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_program1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapProgramDescriptor(soap, "ns1:program", &(a->_ns1__AddProgram::program), "ns1:SoapProgramDescriptor"))
				{	soap_flag_program1--;
					continue;
				}
			if (soap_flag_mapping1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapProgramMappingDescriptor(soap, "ns1:mapping", &(a->_ns1__AddProgram::mapping), "ns1:SoapProgramMappingDescriptor"))
				{	soap_flag_mapping1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddProgram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddProgram, 0, sizeof(_ns1__AddProgram), 0, soap_copy__ns1__AddProgram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__AddProgram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddProgram);
	if (this->soap_out(soap, tag?tag:"ns1:AddProgram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddProgram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddProgram(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddProgram * SOAP_FMAC4 soap_get__ns1__AddProgram(struct soap *soap, _ns1__AddProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AddProgram * SOAP_FMAC2 soap_instantiate__ns1__AddProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddProgram);
		if (size)
			*size = sizeof(_ns1__AddProgram);
		((_ns1__AddProgram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AddProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddProgram);
		for (int i = 0; i < n; i++)
			((_ns1__AddProgram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddProgram %p -> %p\n", q, p));
	*(_ns1__AddProgram*)p = *(_ns1__AddProgram*)q;
}

void ns1__ArrayOfSoapProgramDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, &this->ns1__ArrayOfSoapProgramDescriptor::SoapProgramDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapProgramDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, &this->ns1__ArrayOfSoapProgramDescriptor::SoapProgramDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapProgramDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapProgramDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapProgramDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapProgramDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, "ns1:SoapProgramDescriptor", -1, &(a->ns1__ArrayOfSoapProgramDescriptor::SoapProgramDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapProgramDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapProgramDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapProgramDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapProgramDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapProgramDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapProgramDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor, sizeof(ns1__ArrayOfSoapProgramDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapProgramDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, "ns1:SoapProgramDescriptor", &(a->ns1__ArrayOfSoapProgramDescriptor::SoapProgramDescriptor), "ns1:SoapProgramDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapProgramDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor, 0, sizeof(ns1__ArrayOfSoapProgramDescriptor), 0, soap_copy_ns1__ArrayOfSoapProgramDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapProgramDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapProgramDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapProgramDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapProgramDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapProgramDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapProgramDescriptor(struct soap *soap, ns1__ArrayOfSoapProgramDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapProgramDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapProgramDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapProgramDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapProgramDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapProgramDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapProgramDescriptor);
		((ns1__ArrayOfSoapProgramDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapProgramDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapProgramDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapProgramDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapProgramDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapProgramDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapProgramDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapProgramDescriptor*)p = *(ns1__ArrayOfSoapProgramDescriptor*)q;
}

void ns1__SoapDriverDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapDriverDescriptor::SupportedCommands = NULL;
	this->ns1__SoapDriverDescriptor::SupportedEvents = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapDriverDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapCommandDescriptor(soap, &this->ns1__SoapDriverDescriptor::SupportedCommands);
	soap_serialize_PointerTons1__ArrayOfSoapEventDescriptor(soap, &this->ns1__SoapDriverDescriptor::SupportedEvents);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapDriverDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapDriverDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapDriverDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapDriverDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapDriverDescriptor), "ns1:SoapDriverDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapCommandDescriptor(soap, "ns1:SupportedCommands", -1, &(a->ns1__SoapDriverDescriptor::SupportedCommands), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapEventDescriptor(soap, "ns1:SupportedEvents", -1, &(a->ns1__SoapDriverDescriptor::SupportedEvents), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapDriverDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapDriverDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapDriverDescriptor * SOAP_FMAC4 soap_in_ns1__SoapDriverDescriptor(struct soap *soap, const char *tag, ns1__SoapDriverDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapDriverDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapDriverDescriptor, sizeof(ns1__SoapDriverDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapDriverDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapDriverDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_SupportedCommands1 = 1;
	size_t soap_flag_SupportedEvents1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_SupportedCommands1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapCommandDescriptor(soap, "ns1:SupportedCommands", &(a->ns1__SoapDriverDescriptor::SupportedCommands), "ns1:ArrayOfSoapCommandDescriptor"))
				{	soap_flag_SupportedCommands1--;
					continue;
				}
			if (soap_flag_SupportedEvents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapEventDescriptor(soap, "ns1:SupportedEvents", &(a->ns1__SoapDriverDescriptor::SupportedEvents), "ns1:ArrayOfSoapEventDescriptor"))
				{	soap_flag_SupportedEvents1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapDriverDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapDriverDescriptor, 0, sizeof(ns1__SoapDriverDescriptor), 0, soap_copy_ns1__SoapDriverDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapDriverDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapDriverDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapDriverDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapDriverDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapDriverDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapDriverDescriptor * SOAP_FMAC4 soap_get_ns1__SoapDriverDescriptor(struct soap *soap, ns1__SoapDriverDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapDriverDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapDriverDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapDriverDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapDriverDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapDriverDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDriverDescriptor);
		if (size)
			*size = sizeof(ns1__SoapDriverDescriptor);
		((ns1__SoapDriverDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDriverDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapDriverDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapDriverDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapDriverDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapDriverDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapDriverDescriptor %p -> %p\n", q, p));
	*(ns1__SoapDriverDescriptor*)p = *(ns1__SoapDriverDescriptor*)q;
}

void ns1__ArrayOfSoapDriverDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, &this->ns1__ArrayOfSoapDriverDescriptor::SoapDriverDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapDriverDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, &this->ns1__ArrayOfSoapDriverDescriptor::SoapDriverDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapDriverDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapDriverDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapDriverDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapDriverDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, "ns1:SoapDriverDescriptor", -1, &(a->ns1__ArrayOfSoapDriverDescriptor::SoapDriverDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapDriverDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapDriverDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDriverDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapDriverDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapDriverDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapDriverDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor, sizeof(ns1__ArrayOfSoapDriverDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapDriverDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, "ns1:SoapDriverDescriptor", &(a->ns1__ArrayOfSoapDriverDescriptor::SoapDriverDescriptor), "ns1:SoapDriverDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapDriverDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor, 0, sizeof(ns1__ArrayOfSoapDriverDescriptor), 0, soap_copy_ns1__ArrayOfSoapDriverDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapDriverDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapDriverDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapDriverDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapDriverDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDriverDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapDriverDescriptor(struct soap *soap, ns1__ArrayOfSoapDriverDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapDriverDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapDriverDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapDriverDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapDriverDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapDriverDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapDriverDescriptor);
		((ns1__ArrayOfSoapDriverDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapDriverDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapDriverDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapDriverDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapDriverDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapDriverDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapDriverDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapDriverDescriptor*)p = *(ns1__ArrayOfSoapDriverDescriptor*)q;
}

void ns1__ArrayOfSoapWireDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, &this->ns1__ArrayOfSoapWireDescriptor::SoapWireDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapWireDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, &this->ns1__ArrayOfSoapWireDescriptor::SoapWireDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapWireDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapWireDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapWireDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapWireDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, "ns1:SoapWireDescriptor", -1, &(a->ns1__ArrayOfSoapWireDescriptor::SoapWireDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapWireDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapWireDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapWireDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapWireDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapWireDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor, sizeof(ns1__ArrayOfSoapWireDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapWireDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, "ns1:SoapWireDescriptor", &(a->ns1__ArrayOfSoapWireDescriptor::SoapWireDescriptor), "ns1:SoapWireDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapWireDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor, 0, sizeof(ns1__ArrayOfSoapWireDescriptor), 0, soap_copy_ns1__ArrayOfSoapWireDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapWireDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapWireDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapWireDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapWireDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapWireDescriptor(struct soap *soap, ns1__ArrayOfSoapWireDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapWireDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapWireDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapWireDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapWireDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapWireDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapWireDescriptor);
		((ns1__ArrayOfSoapWireDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapWireDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapWireDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapWireDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapWireDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapWireDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapWireDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapWireDescriptor*)p = *(ns1__ArrayOfSoapWireDescriptor*)q;
}

void ns1__ArrayOfSoapDeviceDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, &this->ns1__ArrayOfSoapDeviceDescriptor::SoapDeviceDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapDeviceDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, &this->ns1__ArrayOfSoapDeviceDescriptor::SoapDeviceDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapDeviceDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapDeviceDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapDeviceDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapDeviceDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, "ns1:SoapDeviceDescriptor", -1, &(a->ns1__ArrayOfSoapDeviceDescriptor::SoapDeviceDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapDeviceDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapDeviceDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDeviceDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapDeviceDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapDeviceDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapDeviceDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor, sizeof(ns1__ArrayOfSoapDeviceDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapDeviceDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, "ns1:SoapDeviceDescriptor", &(a->ns1__ArrayOfSoapDeviceDescriptor::SoapDeviceDescriptor), "ns1:SoapDeviceDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapDeviceDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor, 0, sizeof(ns1__ArrayOfSoapDeviceDescriptor), 0, soap_copy_ns1__ArrayOfSoapDeviceDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapDeviceDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapDeviceDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapDeviceDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapDeviceDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDeviceDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapDeviceDescriptor(struct soap *soap, ns1__ArrayOfSoapDeviceDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapDeviceDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapDeviceDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapDeviceDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapDeviceDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapDeviceDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapDeviceDescriptor);
		((ns1__ArrayOfSoapDeviceDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapDeviceDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapDeviceDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapDeviceDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapDeviceDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapDeviceDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapDeviceDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapDeviceDescriptor*)p = *(ns1__ArrayOfSoapDeviceDescriptor*)q;
}

void ns1__ArrayOfSoapConnectionPointDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, &this->ns1__ArrayOfSoapConnectionPointDescriptor::SoapConnectionPointDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapConnectionPointDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, &this->ns1__ArrayOfSoapConnectionPointDescriptor::SoapConnectionPointDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapConnectionPointDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapConnectionPointDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapConnectionPointDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, "ns1:SoapConnectionPointDescriptor", -1, &(a->ns1__ArrayOfSoapConnectionPointDescriptor::SoapConnectionPointDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapConnectionPointDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapConnectionPointDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapConnectionPointDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapConnectionPointDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapConnectionPointDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor, sizeof(ns1__ArrayOfSoapConnectionPointDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapConnectionPointDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, "ns1:SoapConnectionPointDescriptor", &(a->ns1__ArrayOfSoapConnectionPointDescriptor::SoapConnectionPointDescriptor), "ns1:SoapConnectionPointDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapConnectionPointDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor, 0, sizeof(ns1__ArrayOfSoapConnectionPointDescriptor), 0, soap_copy_ns1__ArrayOfSoapConnectionPointDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapConnectionPointDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapConnectionPointDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapConnectionPointDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapConnectionPointDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapConnectionPointDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, ns1__ArrayOfSoapConnectionPointDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapConnectionPointDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapConnectionPointDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapConnectionPointDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapConnectionPointDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapConnectionPointDescriptor);
		((ns1__ArrayOfSoapConnectionPointDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapConnectionPointDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapConnectionPointDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapConnectionPointDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapConnectionPointDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapConnectionPointDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapConnectionPointDescriptor*)p = *(ns1__ArrayOfSoapConnectionPointDescriptor*)q;
}

void ns1__SoapDeviceDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapDeviceDescriptor::DeviceConnectionPoints = NULL;
	this->ns1__SoapDeviceDescriptor::Pinouts = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapDeviceDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, &this->ns1__SoapDeviceDescriptor::DeviceConnectionPoints);
	soap_serialize_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, &this->ns1__SoapDeviceDescriptor::Pinouts);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapDeviceDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapDeviceDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapDeviceDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapDeviceDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapDeviceDescriptor), "ns1:SoapDeviceDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, "ns1:DeviceConnectionPoints", -1, &(a->ns1__SoapDeviceDescriptor::DeviceConnectionPoints), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, "ns1:Pinouts", -1, &(a->ns1__SoapDeviceDescriptor::Pinouts), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapDeviceDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapDeviceDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapDeviceDescriptor * SOAP_FMAC4 soap_in_ns1__SoapDeviceDescriptor(struct soap *soap, const char *tag, ns1__SoapDeviceDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapDeviceDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapDeviceDescriptor, sizeof(ns1__SoapDeviceDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapDeviceDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapDeviceDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_DeviceConnectionPoints1 = 1;
	size_t soap_flag_Pinouts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_DeviceConnectionPoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, "ns1:DeviceConnectionPoints", &(a->ns1__SoapDeviceDescriptor::DeviceConnectionPoints), "ns1:ArrayOfSoapConnectionPointDescriptor"))
				{	soap_flag_DeviceConnectionPoints1--;
					continue;
				}
			if (soap_flag_Pinouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, "ns1:Pinouts", &(a->ns1__SoapDeviceDescriptor::Pinouts), "ns1:ArrayOfSoapPinoutDescriptor"))
				{	soap_flag_Pinouts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapDeviceDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapDeviceDescriptor, 0, sizeof(ns1__SoapDeviceDescriptor), 0, soap_copy_ns1__SoapDeviceDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapDeviceDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapDeviceDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapDeviceDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapDeviceDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapDeviceDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapDeviceDescriptor * SOAP_FMAC4 soap_get_ns1__SoapDeviceDescriptor(struct soap *soap, ns1__SoapDeviceDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapDeviceDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapDeviceDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapDeviceDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapDeviceDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapDeviceDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDeviceDescriptor);
		if (size)
			*size = sizeof(ns1__SoapDeviceDescriptor);
		((ns1__SoapDeviceDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDeviceDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapDeviceDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapDeviceDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapDeviceDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapDeviceDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapDeviceDescriptor %p -> %p\n", q, p));
	*(ns1__SoapDeviceDescriptor*)p = *(ns1__SoapDeviceDescriptor*)q;
}

void ns1__SoapConnectionPointDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapConnectionPointDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapConnectionPointDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapConnectionPointDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapConnectionPointDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapConnectionPointDescriptor), "ns1:SoapConnectionPointDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapConnectionPointDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapConnectionPointDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapConnectionPointDescriptor * SOAP_FMAC4 soap_in_ns1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, ns1__SoapConnectionPointDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapConnectionPointDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapConnectionPointDescriptor, sizeof(ns1__SoapConnectionPointDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapConnectionPointDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapConnectionPointDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapConnectionPointDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapConnectionPointDescriptor, 0, sizeof(ns1__SoapConnectionPointDescriptor), 0, soap_copy_ns1__SoapConnectionPointDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapConnectionPointDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapConnectionPointDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapConnectionPointDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapConnectionPointDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapConnectionPointDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapConnectionPointDescriptor * SOAP_FMAC4 soap_get_ns1__SoapConnectionPointDescriptor(struct soap *soap, ns1__SoapConnectionPointDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapConnectionPointDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapConnectionPointDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapConnectionPointDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapConnectionPointDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapConnectionPointDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapConnectionPointDescriptor);
		if (size)
			*size = sizeof(ns1__SoapConnectionPointDescriptor);
		((ns1__SoapConnectionPointDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapConnectionPointDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapConnectionPointDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapConnectionPointDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapConnectionPointDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapConnectionPointDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapConnectionPointDescriptor %p -> %p\n", q, p));
	*(ns1__SoapConnectionPointDescriptor*)p = *(ns1__SoapConnectionPointDescriptor*)q;
}

void ns1__ArrayOfSoapWireConnectionPointDescr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, &this->ns1__ArrayOfSoapWireConnectionPointDescr::SoapWireConnectionPointDescr);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapWireConnectionPointDescr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, &this->ns1__ArrayOfSoapWireConnectionPointDescr::SoapWireConnectionPointDescr);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapWireConnectionPointDescr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapWireConnectionPointDescr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapWireConnectionPointDescr *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, "ns1:SoapWireConnectionPointDescr", -1, &(a->ns1__ArrayOfSoapWireConnectionPointDescr::SoapWireConnectionPointDescr), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapWireConnectionPointDescr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapWireConnectionPointDescr(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireConnectionPointDescr * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, const char *tag, ns1__ArrayOfSoapWireConnectionPointDescr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapWireConnectionPointDescr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr, sizeof(ns1__ArrayOfSoapWireConnectionPointDescr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapWireConnectionPointDescr *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, "ns1:SoapWireConnectionPointDescr", &(a->ns1__ArrayOfSoapWireConnectionPointDescr::SoapWireConnectionPointDescr), "ns1:SoapWireConnectionPointDescr"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapWireConnectionPointDescr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr, 0, sizeof(ns1__ArrayOfSoapWireConnectionPointDescr), 0, soap_copy_ns1__ArrayOfSoapWireConnectionPointDescr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapWireConnectionPointDescr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapWireConnectionPointDescr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapWireConnectionPointDescr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapWireConnectionPointDescr(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireConnectionPointDescr * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, ns1__ArrayOfSoapWireConnectionPointDescr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapWireConnectionPointDescr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapWireConnectionPointDescr * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapWireConnectionPointDescr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapWireConnectionPointDescr);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapWireConnectionPointDescr);
		((ns1__ArrayOfSoapWireConnectionPointDescr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapWireConnectionPointDescr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapWireConnectionPointDescr);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapWireConnectionPointDescr*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapWireConnectionPointDescr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapWireConnectionPointDescr %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapWireConnectionPointDescr*)p = *(ns1__ArrayOfSoapWireConnectionPointDescr*)q;
}

void ns1__SoapWireDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapWireDescriptor::WireConnectionPoints = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapWireDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, &this->ns1__SoapWireDescriptor::WireConnectionPoints);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapWireDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapWireDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapWireDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapWireDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapWireDescriptor), "ns1:SoapWireDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, "ns1:WireConnectionPoints", -1, &(a->ns1__SoapWireDescriptor::WireConnectionPoints), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapWireDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapWireDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapWireDescriptor * SOAP_FMAC4 soap_in_ns1__SoapWireDescriptor(struct soap *soap, const char *tag, ns1__SoapWireDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapWireDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapWireDescriptor, sizeof(ns1__SoapWireDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapWireDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapWireDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_WireConnectionPoints1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_WireConnectionPoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, "ns1:WireConnectionPoints", &(a->ns1__SoapWireDescriptor::WireConnectionPoints), "ns1:ArrayOfSoapWireConnectionPointDescr"))
				{	soap_flag_WireConnectionPoints1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapWireDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapWireDescriptor, 0, sizeof(ns1__SoapWireDescriptor), 0, soap_copy_ns1__SoapWireDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapWireDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapWireDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapWireDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapWireDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapWireDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapWireDescriptor * SOAP_FMAC4 soap_get_ns1__SoapWireDescriptor(struct soap *soap, ns1__SoapWireDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapWireDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapWireDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapWireDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapWireDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapWireDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireDescriptor);
		if (size)
			*size = sizeof(ns1__SoapWireDescriptor);
		((ns1__SoapWireDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapWireDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapWireDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapWireDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapWireDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapWireDescriptor %p -> %p\n", q, p));
	*(ns1__SoapWireDescriptor*)p = *(ns1__SoapWireDescriptor*)q;
}

void ns1__SoapWireConnectionPointDescr::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapWireConnectionPointDescr::DeviceDescriptorId = NULL;
	this->ns1__SoapWireConnectionPointDescr::ConnectionPointDescriptorId = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapWireConnectionPointDescr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SoapPropertyDescriptor(soap, &this->ns1__SoapWireConnectionPointDescr::DeviceDescriptorId);
	soap_serialize_PointerTons1__SoapPropertyDescriptor(soap, &this->ns1__SoapWireConnectionPointDescr::ConnectionPointDescriptorId);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapWireConnectionPointDescr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapWireConnectionPointDescr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, int id, const ns1__SoapWireConnectionPointDescr *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapWireConnectionPointDescr), "ns1:SoapWireConnectionPointDescr"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__SoapPropertyDescriptor(soap, "ns1:DeviceDescriptorId", -1, &(a->ns1__SoapWireConnectionPointDescr::DeviceDescriptorId), ""))
		return soap->error;
	if (soap_out_PointerTons1__SoapPropertyDescriptor(soap, "ns1:ConnectionPointDescriptorId", -1, &(a->ns1__SoapWireConnectionPointDescr::ConnectionPointDescriptorId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapWireConnectionPointDescr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapWireConnectionPointDescr(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapWireConnectionPointDescr * SOAP_FMAC4 soap_in_ns1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, ns1__SoapWireConnectionPointDescr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapWireConnectionPointDescr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapWireConnectionPointDescr, sizeof(ns1__SoapWireConnectionPointDescr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapWireConnectionPointDescr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapWireConnectionPointDescr *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_DeviceDescriptorId1 = 1;
	size_t soap_flag_ConnectionPointDescriptorId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_DeviceDescriptorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapPropertyDescriptor(soap, "ns1:DeviceDescriptorId", &(a->ns1__SoapWireConnectionPointDescr::DeviceDescriptorId), "ns1:SoapPropertyDescriptor"))
				{	soap_flag_DeviceDescriptorId1--;
					continue;
				}
			if (soap_flag_ConnectionPointDescriptorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapPropertyDescriptor(soap, "ns1:ConnectionPointDescriptorId", &(a->ns1__SoapWireConnectionPointDescr::ConnectionPointDescriptorId), "ns1:SoapPropertyDescriptor"))
				{	soap_flag_ConnectionPointDescriptorId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapWireConnectionPointDescr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapWireConnectionPointDescr, 0, sizeof(ns1__SoapWireConnectionPointDescr), 0, soap_copy_ns1__SoapWireConnectionPointDescr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapWireConnectionPointDescr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapWireConnectionPointDescr);
	if (this->soap_out(soap, tag?tag:"ns1:SoapWireConnectionPointDescr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapWireConnectionPointDescr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapWireConnectionPointDescr(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapWireConnectionPointDescr * SOAP_FMAC4 soap_get_ns1__SoapWireConnectionPointDescr(struct soap *soap, ns1__SoapWireConnectionPointDescr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapWireConnectionPointDescr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapWireConnectionPointDescr * SOAP_FMAC2 soap_instantiate_ns1__SoapWireConnectionPointDescr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapWireConnectionPointDescr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapWireConnectionPointDescr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireConnectionPointDescr);
		if (size)
			*size = sizeof(ns1__SoapWireConnectionPointDescr);
		((ns1__SoapWireConnectionPointDescr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireConnectionPointDescr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapWireConnectionPointDescr);
		for (int i = 0; i < n; i++)
			((ns1__SoapWireConnectionPointDescr*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapWireConnectionPointDescr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapWireConnectionPointDescr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapWireConnectionPointDescr %p -> %p\n", q, p));
	*(ns1__SoapWireConnectionPointDescr*)p = *(ns1__SoapWireConnectionPointDescr*)q;
}

void ns1__SoapEventParameterDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapEventParameterDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapEventParameterDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapEventParameterDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapEventParameterDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapEventParameterDescriptor), "ns1:SoapEventParameterDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapEventParameterDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapEventParameterDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapEventParameterDescriptor * SOAP_FMAC4 soap_in_ns1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, ns1__SoapEventParameterDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapEventParameterDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapEventParameterDescriptor, sizeof(ns1__SoapEventParameterDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapEventParameterDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapEventParameterDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapEventParameterDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapEventParameterDescriptor, 0, sizeof(ns1__SoapEventParameterDescriptor), 0, soap_copy_ns1__SoapEventParameterDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapEventParameterDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapEventParameterDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapEventParameterDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapEventParameterDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapEventParameterDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapEventParameterDescriptor * SOAP_FMAC4 soap_get_ns1__SoapEventParameterDescriptor(struct soap *soap, ns1__SoapEventParameterDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapEventParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapEventParameterDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapEventParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapEventParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapEventParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventParameterDescriptor);
		if (size)
			*size = sizeof(ns1__SoapEventParameterDescriptor);
		((ns1__SoapEventParameterDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventParameterDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapEventParameterDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapEventParameterDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapEventParameterDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapEventParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapEventParameterDescriptor %p -> %p\n", q, p));
	*(ns1__SoapEventParameterDescriptor*)p = *(ns1__SoapEventParameterDescriptor*)q;
}

void ns1__ArrayOfSoapEventParameterDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, &this->ns1__ArrayOfSoapEventParameterDescriptor::SoapEventParameterDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapEventParameterDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, &this->ns1__ArrayOfSoapEventParameterDescriptor::SoapEventParameterDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapEventParameterDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapEventParameterDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapEventParameterDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, "ns1:SoapEventParameterDescriptor", -1, &(a->ns1__ArrayOfSoapEventParameterDescriptor::SoapEventParameterDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapEventParameterDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapEventParameterDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventParameterDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapEventParameterDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapEventParameterDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor, sizeof(ns1__ArrayOfSoapEventParameterDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapEventParameterDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, "ns1:SoapEventParameterDescriptor", &(a->ns1__ArrayOfSoapEventParameterDescriptor::SoapEventParameterDescriptor), "ns1:SoapEventParameterDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapEventParameterDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor, 0, sizeof(ns1__ArrayOfSoapEventParameterDescriptor), 0, soap_copy_ns1__ArrayOfSoapEventParameterDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapEventParameterDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapEventParameterDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapEventParameterDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapEventParameterDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventParameterDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapEventParameterDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapEventParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapEventParameterDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapEventParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapEventParameterDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapEventParameterDescriptor);
		((ns1__ArrayOfSoapEventParameterDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapEventParameterDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapEventParameterDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapEventParameterDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapEventParameterDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapEventParameterDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapEventParameterDescriptor*)p = *(ns1__ArrayOfSoapEventParameterDescriptor*)q;
}

void ns1__SoapEventDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapEventDescriptor::EventParameters = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapEventDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, &this->ns1__SoapEventDescriptor::EventParameters);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapEventDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapEventDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapEventDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapEventDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapEventDescriptor), "ns1:SoapEventDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, "ns1:EventParameters", -1, &(a->ns1__SoapEventDescriptor::EventParameters), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapEventDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapEventDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapEventDescriptor * SOAP_FMAC4 soap_in_ns1__SoapEventDescriptor(struct soap *soap, const char *tag, ns1__SoapEventDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapEventDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapEventDescriptor, sizeof(ns1__SoapEventDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapEventDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapEventDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_EventParameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_EventParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, "ns1:EventParameters", &(a->ns1__SoapEventDescriptor::EventParameters), "ns1:ArrayOfSoapEventParameterDescriptor"))
				{	soap_flag_EventParameters1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapEventDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapEventDescriptor, 0, sizeof(ns1__SoapEventDescriptor), 0, soap_copy_ns1__SoapEventDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapEventDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapEventDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapEventDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapEventDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapEventDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapEventDescriptor * SOAP_FMAC4 soap_get_ns1__SoapEventDescriptor(struct soap *soap, ns1__SoapEventDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapEventDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapEventDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapEventDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapEventDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapEventDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventDescriptor);
		if (size)
			*size = sizeof(ns1__SoapEventDescriptor);
		((ns1__SoapEventDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapEventDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapEventDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapEventDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapEventDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapEventDescriptor %p -> %p\n", q, p));
	*(ns1__SoapEventDescriptor*)p = *(ns1__SoapEventDescriptor*)q;
}

void ns1__ArrayOfSoapEventDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, &this->ns1__ArrayOfSoapEventDescriptor::SoapEventDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapEventDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, &this->ns1__ArrayOfSoapEventDescriptor::SoapEventDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapEventDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapEventDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapEventDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapEventDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, "ns1:SoapEventDescriptor", -1, &(a->ns1__ArrayOfSoapEventDescriptor::SoapEventDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapEventDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapEventDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapEventDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapEventDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapEventDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor, sizeof(ns1__ArrayOfSoapEventDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapEventDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, "ns1:SoapEventDescriptor", &(a->ns1__ArrayOfSoapEventDescriptor::SoapEventDescriptor), "ns1:SoapEventDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapEventDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor, 0, sizeof(ns1__ArrayOfSoapEventDescriptor), 0, soap_copy_ns1__ArrayOfSoapEventDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapEventDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapEventDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapEventDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapEventDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapEventDescriptor(struct soap *soap, ns1__ArrayOfSoapEventDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapEventDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapEventDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapEventDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapEventDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapEventDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapEventDescriptor);
		((ns1__ArrayOfSoapEventDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapEventDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapEventDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapEventDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapEventDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapEventDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapEventDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapEventDescriptor*)p = *(ns1__ArrayOfSoapEventDescriptor*)q;
}

void ns1__SoapCommandParameterDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapCommandParameterDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapCommandParameterDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapCommandParameterDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapCommandParameterDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapCommandParameterDescriptor), "ns1:SoapCommandParameterDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapCommandParameterDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapCommandParameterDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapCommandParameterDescriptor * SOAP_FMAC4 soap_in_ns1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, ns1__SoapCommandParameterDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapCommandParameterDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapCommandParameterDescriptor, sizeof(ns1__SoapCommandParameterDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapCommandParameterDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapCommandParameterDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapCommandParameterDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapCommandParameterDescriptor, 0, sizeof(ns1__SoapCommandParameterDescriptor), 0, soap_copy_ns1__SoapCommandParameterDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapCommandParameterDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapCommandParameterDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapCommandParameterDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapCommandParameterDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapCommandParameterDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapCommandParameterDescriptor * SOAP_FMAC4 soap_get_ns1__SoapCommandParameterDescriptor(struct soap *soap, ns1__SoapCommandParameterDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapCommandParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapCommandParameterDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapCommandParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapCommandParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapCommandParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandParameterDescriptor);
		if (size)
			*size = sizeof(ns1__SoapCommandParameterDescriptor);
		((ns1__SoapCommandParameterDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandParameterDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapCommandParameterDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapCommandParameterDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapCommandParameterDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapCommandParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapCommandParameterDescriptor %p -> %p\n", q, p));
	*(ns1__SoapCommandParameterDescriptor*)p = *(ns1__SoapCommandParameterDescriptor*)q;
}

void ns1__ArrayOfSoapCommandParameterDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, &this->ns1__ArrayOfSoapCommandParameterDescriptor::SoapCommandParameterDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapCommandParameterDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, &this->ns1__ArrayOfSoapCommandParameterDescriptor::SoapCommandParameterDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapCommandParameterDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapCommandParameterDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapCommandParameterDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, "ns1:SoapCommandParameterDescriptor", -1, &(a->ns1__ArrayOfSoapCommandParameterDescriptor::SoapCommandParameterDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapCommandParameterDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapCommandParameterDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandParameterDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapCommandParameterDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapCommandParameterDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor, sizeof(ns1__ArrayOfSoapCommandParameterDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapCommandParameterDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, "ns1:SoapCommandParameterDescriptor", &(a->ns1__ArrayOfSoapCommandParameterDescriptor::SoapCommandParameterDescriptor), "ns1:SoapCommandParameterDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapCommandParameterDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor, 0, sizeof(ns1__ArrayOfSoapCommandParameterDescriptor), 0, soap_copy_ns1__ArrayOfSoapCommandParameterDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapCommandParameterDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapCommandParameterDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapCommandParameterDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapCommandParameterDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandParameterDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandParameterDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapCommandParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapCommandParameterDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapCommandParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapCommandParameterDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapCommandParameterDescriptor);
		((ns1__ArrayOfSoapCommandParameterDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapCommandParameterDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapCommandParameterDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapCommandParameterDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapCommandParameterDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapCommandParameterDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapCommandParameterDescriptor*)p = *(ns1__ArrayOfSoapCommandParameterDescriptor*)q;
}

void ns1__SoapCommandDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapCommandDescriptor::CommandParameters = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapCommandDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, &this->ns1__SoapCommandDescriptor::CommandParameters);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapCommandDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapCommandDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapCommandDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapCommandDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapCommandDescriptor), "ns1:SoapCommandDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, "ns1:CommandParameters", -1, &(a->ns1__SoapCommandDescriptor::CommandParameters), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapCommandDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapCommandDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapCommandDescriptor * SOAP_FMAC4 soap_in_ns1__SoapCommandDescriptor(struct soap *soap, const char *tag, ns1__SoapCommandDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapCommandDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapCommandDescriptor, sizeof(ns1__SoapCommandDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapCommandDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapCommandDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_CommandParameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_CommandParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, "ns1:CommandParameters", &(a->ns1__SoapCommandDescriptor::CommandParameters), "ns1:ArrayOfSoapCommandParameterDescriptor"))
				{	soap_flag_CommandParameters1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapCommandDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapCommandDescriptor, 0, sizeof(ns1__SoapCommandDescriptor), 0, soap_copy_ns1__SoapCommandDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapCommandDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapCommandDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapCommandDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapCommandDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapCommandDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapCommandDescriptor * SOAP_FMAC4 soap_get_ns1__SoapCommandDescriptor(struct soap *soap, ns1__SoapCommandDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapCommandDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapCommandDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapCommandDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapCommandDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapCommandDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandDescriptor);
		if (size)
			*size = sizeof(ns1__SoapCommandDescriptor);
		((ns1__SoapCommandDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapCommandDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapCommandDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapCommandDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapCommandDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapCommandDescriptor %p -> %p\n", q, p));
	*(ns1__SoapCommandDescriptor*)p = *(ns1__SoapCommandDescriptor*)q;
}

void ns1__ArrayOfSoapCommandDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, &this->ns1__ArrayOfSoapCommandDescriptor::SoapCommandDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapCommandDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, &this->ns1__ArrayOfSoapCommandDescriptor::SoapCommandDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapCommandDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapCommandDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapCommandDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapCommandDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, "ns1:SoapCommandDescriptor", -1, &(a->ns1__ArrayOfSoapCommandDescriptor::SoapCommandDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapCommandDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapCommandDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapCommandDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapCommandDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapCommandDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor, sizeof(ns1__ArrayOfSoapCommandDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapCommandDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, "ns1:SoapCommandDescriptor", &(a->ns1__ArrayOfSoapCommandDescriptor::SoapCommandDescriptor), "ns1:SoapCommandDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapCommandDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor, 0, sizeof(ns1__ArrayOfSoapCommandDescriptor), 0, soap_copy_ns1__ArrayOfSoapCommandDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapCommandDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapCommandDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapCommandDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapCommandDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapCommandDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapCommandDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapCommandDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapCommandDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapCommandDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapCommandDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapCommandDescriptor);
		((ns1__ArrayOfSoapCommandDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapCommandDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapCommandDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapCommandDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapCommandDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapCommandDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapCommandDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapCommandDescriptor*)p = *(ns1__ArrayOfSoapCommandDescriptor*)q;
}

void ns1__SoapPinoutDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapPinoutDescriptor::SupportedCommands = NULL;
	this->ns1__SoapPinoutDescriptor::SupportedEvents = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapPinoutDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapCommandDescriptor(soap, &this->ns1__SoapPinoutDescriptor::SupportedCommands);
	soap_serialize_PointerTons1__ArrayOfSoapEventDescriptor(soap, &this->ns1__SoapPinoutDescriptor::SupportedEvents);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapPinoutDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapPinoutDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapPinoutDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapPinoutDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapPinoutDescriptor), "ns1:SoapPinoutDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapCommandDescriptor(soap, "ns1:SupportedCommands", -1, &(a->ns1__SoapPinoutDescriptor::SupportedCommands), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapEventDescriptor(soap, "ns1:SupportedEvents", -1, &(a->ns1__SoapPinoutDescriptor::SupportedEvents), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapPinoutDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapPinoutDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapPinoutDescriptor * SOAP_FMAC4 soap_in_ns1__SoapPinoutDescriptor(struct soap *soap, const char *tag, ns1__SoapPinoutDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapPinoutDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapPinoutDescriptor, sizeof(ns1__SoapPinoutDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapPinoutDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapPinoutDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_SupportedCommands1 = 1;
	size_t soap_flag_SupportedEvents1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_SupportedCommands1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapCommandDescriptor(soap, "ns1:SupportedCommands", &(a->ns1__SoapPinoutDescriptor::SupportedCommands), "ns1:ArrayOfSoapCommandDescriptor"))
				{	soap_flag_SupportedCommands1--;
					continue;
				}
			if (soap_flag_SupportedEvents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapEventDescriptor(soap, "ns1:SupportedEvents", &(a->ns1__SoapPinoutDescriptor::SupportedEvents), "ns1:ArrayOfSoapEventDescriptor"))
				{	soap_flag_SupportedEvents1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapPinoutDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapPinoutDescriptor, 0, sizeof(ns1__SoapPinoutDescriptor), 0, soap_copy_ns1__SoapPinoutDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapPinoutDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapPinoutDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapPinoutDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapPinoutDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapPinoutDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapPinoutDescriptor * SOAP_FMAC4 soap_get_ns1__SoapPinoutDescriptor(struct soap *soap, ns1__SoapPinoutDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapPinoutDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapPinoutDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapPinoutDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapPinoutDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapPinoutDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPinoutDescriptor);
		if (size)
			*size = sizeof(ns1__SoapPinoutDescriptor);
		((ns1__SoapPinoutDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPinoutDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapPinoutDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapPinoutDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapPinoutDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapPinoutDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapPinoutDescriptor %p -> %p\n", q, p));
	*(ns1__SoapPinoutDescriptor*)p = *(ns1__SoapPinoutDescriptor*)q;
}

void ns1__ArrayOfSoapPinoutDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, &this->ns1__ArrayOfSoapPinoutDescriptor::SoapPinoutDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapPinoutDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, &this->ns1__ArrayOfSoapPinoutDescriptor::SoapPinoutDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapPinoutDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapPinoutDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapPinoutDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapPinoutDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, "ns1:SoapPinoutDescriptor", -1, &(a->ns1__ArrayOfSoapPinoutDescriptor::SoapPinoutDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapPinoutDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapPinoutDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPinoutDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapPinoutDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapPinoutDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapPinoutDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor, sizeof(ns1__ArrayOfSoapPinoutDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapPinoutDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, "ns1:SoapPinoutDescriptor", &(a->ns1__ArrayOfSoapPinoutDescriptor::SoapPinoutDescriptor), "ns1:SoapPinoutDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapPinoutDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor, 0, sizeof(ns1__ArrayOfSoapPinoutDescriptor), 0, soap_copy_ns1__ArrayOfSoapPinoutDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapPinoutDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapPinoutDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapPinoutDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapPinoutDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPinoutDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapPinoutDescriptor(struct soap *soap, ns1__ArrayOfSoapPinoutDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapPinoutDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapPinoutDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapPinoutDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapPinoutDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapPinoutDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapPinoutDescriptor);
		((ns1__ArrayOfSoapPinoutDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapPinoutDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapPinoutDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapPinoutDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapPinoutDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapPinoutDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapPinoutDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapPinoutDescriptor*)p = *(ns1__ArrayOfSoapPinoutDescriptor*)q;
}

void ns1__SoapProgramMappingDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapProgramMappingDescriptor::PinoutMappings = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapProgramMappingDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, &this->ns1__SoapProgramMappingDescriptor::PinoutMappings);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapProgramMappingDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapProgramMappingDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapProgramMappingDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapProgramMappingDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapProgramMappingDescriptor), "ns1:SoapProgramMappingDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, "ns1:PinoutMappings", -1, &(a->ns1__SoapProgramMappingDescriptor::PinoutMappings), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapProgramMappingDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapProgramMappingDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapProgramMappingDescriptor * SOAP_FMAC4 soap_in_ns1__SoapProgramMappingDescriptor(struct soap *soap, const char *tag, ns1__SoapProgramMappingDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapProgramMappingDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapProgramMappingDescriptor, sizeof(ns1__SoapProgramMappingDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapProgramMappingDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapProgramMappingDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_PinoutMappings1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_PinoutMappings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, "ns1:PinoutMappings", &(a->ns1__SoapProgramMappingDescriptor::PinoutMappings), "ns1:ArrayOfSoapPinoutDescriptor"))
				{	soap_flag_PinoutMappings1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapProgramMappingDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapProgramMappingDescriptor, 0, sizeof(ns1__SoapProgramMappingDescriptor), 0, soap_copy_ns1__SoapProgramMappingDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapProgramMappingDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapProgramMappingDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapProgramMappingDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapProgramMappingDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapProgramMappingDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapProgramMappingDescriptor * SOAP_FMAC4 soap_get_ns1__SoapProgramMappingDescriptor(struct soap *soap, ns1__SoapProgramMappingDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapProgramMappingDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapProgramMappingDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapProgramMappingDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapProgramMappingDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapProgramMappingDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramMappingDescriptor);
		if (size)
			*size = sizeof(ns1__SoapProgramMappingDescriptor);
		((ns1__SoapProgramMappingDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramMappingDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapProgramMappingDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapProgramMappingDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapProgramMappingDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapProgramMappingDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapProgramMappingDescriptor %p -> %p\n", q, p));
	*(ns1__SoapProgramMappingDescriptor*)p = *(ns1__SoapProgramMappingDescriptor*)q;
}

void ns1__SoapPropertyDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapPropertyDescriptor::Name = NULL;
	this->ns1__SoapPropertyDescriptor::DataType = NULL;
	this->ns1__SoapPropertyDescriptor::Value = NULL;
	/* transient soap skipped */
}

void ns1__SoapPropertyDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__SoapPropertyDescriptor::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SoapPropertyDescriptor::DataType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SoapPropertyDescriptor::Value);
	/* transient soap skipped */
}

int ns1__SoapPropertyDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapPropertyDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapPropertyDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapPropertyDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapPropertyDescriptor), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Name", -1, &(a->ns1__SoapPropertyDescriptor::Name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DataType", -1, &(a->ns1__SoapPropertyDescriptor::DataType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Value", -1, &(a->ns1__SoapPropertyDescriptor::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapPropertyDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapPropertyDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapPropertyDescriptor * SOAP_FMAC4 soap_in_ns1__SoapPropertyDescriptor(struct soap *soap, const char *tag, ns1__SoapPropertyDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapPropertyDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapPropertyDescriptor, sizeof(ns1__SoapPropertyDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapPropertyDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapPropertyDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_DataType1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Name", &(a->ns1__SoapPropertyDescriptor::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_DataType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:DataType", &(a->ns1__SoapPropertyDescriptor::DataType), "xsd:string"))
				{	soap_flag_DataType1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Value", &(a->ns1__SoapPropertyDescriptor::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapPropertyDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapPropertyDescriptor, 0, sizeof(ns1__SoapPropertyDescriptor), 0, soap_copy_ns1__SoapPropertyDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapPropertyDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapPropertyDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapPropertyDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapPropertyDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapPropertyDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapPropertyDescriptor * SOAP_FMAC4 soap_get_ns1__SoapPropertyDescriptor(struct soap *soap, ns1__SoapPropertyDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapPropertyDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapPropertyDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapPropertyDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapPropertyDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapPropertyDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPropertyDescriptor);
		if (size)
			*size = sizeof(ns1__SoapPropertyDescriptor);
		((ns1__SoapPropertyDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPropertyDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapPropertyDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapPropertyDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapPropertyDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapPropertyDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapPropertyDescriptor %p -> %p\n", q, p));
	*(ns1__SoapPropertyDescriptor*)p = *(ns1__SoapPropertyDescriptor*)q;
}

void ns1__ArrayOfSoapPropertyDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, &this->ns1__ArrayOfSoapPropertyDescriptor::SoapPropertyDescriptor);
	/* transient soap skipped */
}

void ns1__ArrayOfSoapPropertyDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, &this->ns1__ArrayOfSoapPropertyDescriptor::SoapPropertyDescriptor);
	/* transient soap skipped */
}

int ns1__ArrayOfSoapPropertyDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSoapPropertyDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSoapPropertyDescriptor(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSoapPropertyDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, "ns1:SoapPropertyDescriptor", -1, &(a->ns1__ArrayOfSoapPropertyDescriptor::SoapPropertyDescriptor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSoapPropertyDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSoapPropertyDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPropertyDescriptor * SOAP_FMAC4 soap_in_ns1__ArrayOfSoapPropertyDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapPropertyDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSoapPropertyDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor, sizeof(ns1__ArrayOfSoapPropertyDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfSoapPropertyDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, "ns1:SoapPropertyDescriptor", &(a->ns1__ArrayOfSoapPropertyDescriptor::SoapPropertyDescriptor), "ns1:SoapPropertyDescriptor"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSoapPropertyDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor, 0, sizeof(ns1__ArrayOfSoapPropertyDescriptor), 0, soap_copy_ns1__ArrayOfSoapPropertyDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfSoapPropertyDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSoapPropertyDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSoapPropertyDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSoapPropertyDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPropertyDescriptor * SOAP_FMAC4 soap_get_ns1__ArrayOfSoapPropertyDescriptor(struct soap *soap, ns1__ArrayOfSoapPropertyDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSoapPropertyDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfSoapPropertyDescriptor * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSoapPropertyDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSoapPropertyDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapPropertyDescriptor);
		if (size)
			*size = sizeof(ns1__ArrayOfSoapPropertyDescriptor);
		((ns1__ArrayOfSoapPropertyDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfSoapPropertyDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfSoapPropertyDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfSoapPropertyDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfSoapPropertyDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfSoapPropertyDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfSoapPropertyDescriptor %p -> %p\n", q, p));
	*(ns1__ArrayOfSoapPropertyDescriptor*)p = *(ns1__ArrayOfSoapPropertyDescriptor*)q;
}

void ns1__SoapBaseObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapBaseObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapBaseObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapBaseObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapBaseObject(struct soap *soap, const char *tag, int id, const ns1__SoapBaseObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapBaseObject), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapBaseObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapBaseObject(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapBaseObject * SOAP_FMAC4 soap_in_ns1__SoapBaseObject(struct soap *soap, const char *tag, ns1__SoapBaseObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapBaseObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapBaseObject, sizeof(ns1__SoapBaseObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapBaseObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapBaseObject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapBaseObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapBaseObject, 0, sizeof(ns1__SoapBaseObject), 0, soap_copy_ns1__SoapBaseObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapBaseObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapBaseObject);
	if (this->soap_out(soap, tag?tag:"ns1:SoapBaseObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapBaseObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapBaseObject(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapBaseObject * SOAP_FMAC4 soap_get_ns1__SoapBaseObject(struct soap *soap, ns1__SoapBaseObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapBaseObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapBaseObject * SOAP_FMAC2 soap_instantiate_ns1__SoapBaseObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapBaseObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapBaseObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:SoapProgramDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapProgramDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapProgramDescriptor);
			((ns1__SoapProgramDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapProgramDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapProgramDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapProgramDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapProgramMappingDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapProgramMappingDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramMappingDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapProgramMappingDescriptor);
			((ns1__SoapProgramMappingDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramMappingDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapProgramMappingDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapProgramMappingDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapProgramMappingDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapPinoutDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapPinoutDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPinoutDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapPinoutDescriptor);
			((ns1__SoapPinoutDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapPinoutDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapPinoutDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapPinoutDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapPinoutDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapCommandDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapCommandDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapCommandDescriptor);
			((ns1__SoapCommandDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapCommandDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapCommandDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapCommandDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapCommandParameterDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapCommandParameterDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandParameterDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapCommandParameterDescriptor);
			((ns1__SoapCommandParameterDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapCommandParameterDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapCommandParameterDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapCommandParameterDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapCommandParameterDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapEventDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapEventDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapEventDescriptor);
			((ns1__SoapEventDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapEventDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapEventDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapEventDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapEventParameterDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapEventParameterDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventParameterDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapEventParameterDescriptor);
			((ns1__SoapEventParameterDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapEventParameterDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapEventParameterDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapEventParameterDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapEventParameterDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapWireConnectionPointDescr"))
	{	cp->type = SOAP_TYPE_ns1__SoapWireConnectionPointDescr;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireConnectionPointDescr);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapWireConnectionPointDescr);
			((ns1__SoapWireConnectionPointDescr*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireConnectionPointDescr[n]);
			if (size)
				*size = n * sizeof(ns1__SoapWireConnectionPointDescr);
			for (int i = 0; i < n; i++)
				((ns1__SoapWireConnectionPointDescr*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapWireConnectionPointDescr*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapWireDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapWireDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapWireDescriptor);
			((ns1__SoapWireDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapWireDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapWireDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapWireDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapWireDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapConnectionPointDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapConnectionPointDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapConnectionPointDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapConnectionPointDescriptor);
			((ns1__SoapConnectionPointDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapConnectionPointDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapConnectionPointDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapConnectionPointDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapConnectionPointDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapDeviceDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapDeviceDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDeviceDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapDeviceDescriptor);
			((ns1__SoapDeviceDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDeviceDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapDeviceDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapDeviceDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapDeviceDescriptor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SoapDriverDescriptor"))
	{	cp->type = SOAP_TYPE_ns1__SoapDriverDescriptor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDriverDescriptor);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SoapDriverDescriptor);
			((ns1__SoapDriverDescriptor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SoapDriverDescriptor[n]);
			if (size)
				*size = n * sizeof(ns1__SoapDriverDescriptor);
			for (int i = 0; i < n; i++)
				((ns1__SoapDriverDescriptor*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SoapDriverDescriptor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapBaseObject);
		if (size)
			*size = sizeof(ns1__SoapBaseObject);
		((ns1__SoapBaseObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapBaseObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapBaseObject);
		for (int i = 0; i < n; i++)
			((ns1__SoapBaseObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapBaseObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapBaseObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapBaseObject %p -> %p\n", q, p));
	*(ns1__SoapBaseObject*)p = *(ns1__SoapBaseObject*)q;
}

void ns1__SoapProgramDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapProgramDescriptor::Devices = NULL;
	this->ns1__SoapProgramDescriptor::Wires = NULL;
	this->ns1__SoapProgramDescriptor::PowerWire = NULL;
	this->ns1__SoapBaseObject::Properties = NULL;
	/* transient soap skipped */
}

void ns1__SoapProgramDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, &this->ns1__SoapProgramDescriptor::Devices);
	soap_serialize_PointerTons1__ArrayOfSoapWireDescriptor(soap, &this->ns1__SoapProgramDescriptor::Wires);
	soap_serialize_PointerTons1__SoapWireDescriptor(soap, &this->ns1__SoapProgramDescriptor::PowerWire);
	soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, &this->ns1__SoapBaseObject::Properties);
	/* transient soap skipped */
}

int ns1__SoapProgramDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapProgramDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapProgramDescriptor(struct soap *soap, const char *tag, int id, const ns1__SoapProgramDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapProgramDescriptor), "ns1:SoapProgramDescriptor"))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", -1, &(a->ns1__SoapBaseObject::Properties), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, "ns1:Devices", -1, &(a->ns1__SoapProgramDescriptor::Devices), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSoapWireDescriptor(soap, "ns1:Wires", -1, &(a->ns1__SoapProgramDescriptor::Wires), ""))
		return soap->error;
	if (soap_out_PointerTons1__SoapWireDescriptor(soap, "ns1:PowerWire", -1, &(a->ns1__SoapProgramDescriptor::PowerWire), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapProgramDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapProgramDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapProgramDescriptor * SOAP_FMAC4 soap_in_ns1__SoapProgramDescriptor(struct soap *soap, const char *tag, ns1__SoapProgramDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapProgramDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapProgramDescriptor, sizeof(ns1__SoapProgramDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapProgramDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapProgramDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Properties2 = 1;
	size_t soap_flag_Devices1 = 1;
	size_t soap_flag_Wires1 = 1;
	size_t soap_flag_PowerWire1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, "ns1:Properties", &(a->ns1__SoapBaseObject::Properties), "ns1:ArrayOfSoapPropertyDescriptor"))
				{	soap_flag_Properties2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Devices1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, "ns1:Devices", &(a->ns1__SoapProgramDescriptor::Devices), "ns1:ArrayOfSoapDeviceDescriptor"))
				{	soap_flag_Devices1--;
					continue;
				}
			if (soap_flag_Wires1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSoapWireDescriptor(soap, "ns1:Wires", &(a->ns1__SoapProgramDescriptor::Wires), "ns1:ArrayOfSoapWireDescriptor"))
				{	soap_flag_Wires1--;
					continue;
				}
			if (soap_flag_PowerWire1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapWireDescriptor(soap, "ns1:PowerWire", &(a->ns1__SoapProgramDescriptor::PowerWire), "ns1:SoapWireDescriptor"))
				{	soap_flag_PowerWire1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapProgramDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapProgramDescriptor, 0, sizeof(ns1__SoapProgramDescriptor), 0, soap_copy_ns1__SoapProgramDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SoapProgramDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapProgramDescriptor);
	if (this->soap_out(soap, tag?tag:"ns1:SoapProgramDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapProgramDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapProgramDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapProgramDescriptor * SOAP_FMAC4 soap_get_ns1__SoapProgramDescriptor(struct soap *soap, ns1__SoapProgramDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapProgramDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SoapProgramDescriptor * SOAP_FMAC2 soap_instantiate_ns1__SoapProgramDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapProgramDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapProgramDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramDescriptor);
		if (size)
			*size = sizeof(ns1__SoapProgramDescriptor);
		((ns1__SoapProgramDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SoapProgramDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapProgramDescriptor);
		for (int i = 0; i < n; i++)
			((ns1__SoapProgramDescriptor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapProgramDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapProgramDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapProgramDescriptor %p -> %p\n", q, p));
	*(ns1__SoapProgramDescriptor*)p = *(ns1__SoapProgramDescriptor*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRunningProgramsStatus(struct soap *soap, struct __ns1__GetRunningProgramsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRunningProgramsStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRunningProgramsStatus(struct soap *soap, const struct __ns1__GetRunningProgramsStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetRunningProgramsStatus(soap, &a->ns1__GetRunningProgramsStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, int id, const struct __ns1__GetRunningProgramsStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRunningProgramsStatus(soap, "ns1:GetRunningProgramsStatus", -1, &a->ns1__GetRunningProgramsStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRunningProgramsStatus * SOAP_FMAC4 soap_in___ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, struct __ns1__GetRunningProgramsStatus *a, const char *type)
{
	size_t soap_flag_ns1__GetRunningProgramsStatus = 1;
	short soap_flag;
	a = (struct __ns1__GetRunningProgramsStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRunningProgramsStatus, sizeof(struct __ns1__GetRunningProgramsStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRunningProgramsStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRunningProgramsStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetRunningProgramsStatus(soap, "ns1:GetRunningProgramsStatus", &a->ns1__GetRunningProgramsStatus, ""))
				{	soap_flag_ns1__GetRunningProgramsStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRunningProgramsStatus(struct soap *soap, const struct __ns1__GetRunningProgramsStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRunningProgramsStatus(soap, tag?tag:"-ns1:GetRunningProgramsStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRunningProgramsStatus * SOAP_FMAC4 soap_get___ns1__GetRunningProgramsStatus(struct soap *soap, struct __ns1__GetRunningProgramsStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRunningProgramsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRunningProgramsStatus * SOAP_FMAC2 soap_instantiate___ns1__GetRunningProgramsStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRunningProgramsStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRunningProgramsStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRunningProgramsStatus);
		if (size)
			*size = sizeof(struct __ns1__GetRunningProgramsStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRunningProgramsStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetRunningProgramsStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetRunningProgramsStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRunningProgramsStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRunningProgramsStatus %p -> %p\n", q, p));
	*(struct __ns1__GetRunningProgramsStatus*)p = *(struct __ns1__GetRunningProgramsStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetProgramStatus(struct soap *soap, struct __ns1__GetProgramStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetProgramStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetProgramStatus(struct soap *soap, const struct __ns1__GetProgramStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetProgramStatus(soap, &a->ns1__GetProgramStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetProgramStatus(struct soap *soap, const char *tag, int id, const struct __ns1__GetProgramStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetProgramStatus(soap, "ns1:GetProgramStatus", -1, &a->ns1__GetProgramStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProgramStatus * SOAP_FMAC4 soap_in___ns1__GetProgramStatus(struct soap *soap, const char *tag, struct __ns1__GetProgramStatus *a, const char *type)
{
	size_t soap_flag_ns1__GetProgramStatus = 1;
	short soap_flag;
	a = (struct __ns1__GetProgramStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetProgramStatus, sizeof(struct __ns1__GetProgramStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetProgramStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetProgramStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetProgramStatus(soap, "ns1:GetProgramStatus", &a->ns1__GetProgramStatus, ""))
				{	soap_flag_ns1__GetProgramStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetProgramStatus(struct soap *soap, const struct __ns1__GetProgramStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetProgramStatus(soap, tag?tag:"-ns1:GetProgramStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProgramStatus * SOAP_FMAC4 soap_get___ns1__GetProgramStatus(struct soap *soap, struct __ns1__GetProgramStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetProgramStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetProgramStatus * SOAP_FMAC2 soap_instantiate___ns1__GetProgramStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetProgramStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetProgramStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetProgramStatus);
		if (size)
			*size = sizeof(struct __ns1__GetProgramStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetProgramStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetProgramStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetProgramStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetProgramStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetProgramStatus %p -> %p\n", q, p));
	*(struct __ns1__GetProgramStatus*)p = *(struct __ns1__GetProgramStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetProgram(struct soap *soap, struct __ns1__GetProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetProgram = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetProgram(struct soap *soap, const struct __ns1__GetProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetProgram(soap, &a->ns1__GetProgram);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetProgram(struct soap *soap, const char *tag, int id, const struct __ns1__GetProgram *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetProgram(soap, "ns1:GetProgram", -1, &a->ns1__GetProgram, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProgram * SOAP_FMAC4 soap_in___ns1__GetProgram(struct soap *soap, const char *tag, struct __ns1__GetProgram *a, const char *type)
{
	size_t soap_flag_ns1__GetProgram = 1;
	short soap_flag;
	a = (struct __ns1__GetProgram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetProgram, sizeof(struct __ns1__GetProgram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetProgram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetProgram && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetProgram(soap, "ns1:GetProgram", &a->ns1__GetProgram, ""))
				{	soap_flag_ns1__GetProgram--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetProgram(struct soap *soap, const struct __ns1__GetProgram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetProgram(soap, tag?tag:"-ns1:GetProgram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProgram * SOAP_FMAC4 soap_get___ns1__GetProgram(struct soap *soap, struct __ns1__GetProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetProgram * SOAP_FMAC2 soap_instantiate___ns1__GetProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetProgram);
		if (size)
			*size = sizeof(struct __ns1__GetProgram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetProgram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetProgram %p -> %p\n", q, p));
	*(struct __ns1__GetProgram*)p = *(struct __ns1__GetProgram*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPrograms(struct soap *soap, struct __ns1__GetPrograms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPrograms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPrograms(struct soap *soap, const struct __ns1__GetPrograms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPrograms(soap, &a->ns1__GetPrograms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPrograms(struct soap *soap, const char *tag, int id, const struct __ns1__GetPrograms *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPrograms(soap, "ns1:GetPrograms", -1, &a->ns1__GetPrograms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPrograms * SOAP_FMAC4 soap_in___ns1__GetPrograms(struct soap *soap, const char *tag, struct __ns1__GetPrograms *a, const char *type)
{
	size_t soap_flag_ns1__GetPrograms = 1;
	short soap_flag;
	a = (struct __ns1__GetPrograms *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPrograms, sizeof(struct __ns1__GetPrograms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPrograms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPrograms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPrograms(soap, "ns1:GetPrograms", &a->ns1__GetPrograms, ""))
				{	soap_flag_ns1__GetPrograms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPrograms(struct soap *soap, const struct __ns1__GetPrograms *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPrograms(soap, tag?tag:"-ns1:GetPrograms", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPrograms * SOAP_FMAC4 soap_get___ns1__GetPrograms(struct soap *soap, struct __ns1__GetPrograms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPrograms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPrograms * SOAP_FMAC2 soap_instantiate___ns1__GetPrograms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPrograms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPrograms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPrograms);
		if (size)
			*size = sizeof(struct __ns1__GetPrograms);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPrograms[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetPrograms);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetPrograms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPrograms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPrograms %p -> %p\n", q, p));
	*(struct __ns1__GetPrograms*)p = *(struct __ns1__GetPrograms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDrivers(struct soap *soap, struct __ns1__GetDrivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDrivers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDrivers(struct soap *soap, const struct __ns1__GetDrivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDrivers(soap, &a->ns1__GetDrivers);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDrivers(struct soap *soap, const char *tag, int id, const struct __ns1__GetDrivers *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDrivers(soap, "ns1:GetDrivers", -1, &a->ns1__GetDrivers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDrivers * SOAP_FMAC4 soap_in___ns1__GetDrivers(struct soap *soap, const char *tag, struct __ns1__GetDrivers *a, const char *type)
{
	size_t soap_flag_ns1__GetDrivers = 1;
	short soap_flag;
	a = (struct __ns1__GetDrivers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDrivers, sizeof(struct __ns1__GetDrivers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDrivers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDrivers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDrivers(soap, "ns1:GetDrivers", &a->ns1__GetDrivers, ""))
				{	soap_flag_ns1__GetDrivers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDrivers(struct soap *soap, const struct __ns1__GetDrivers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDrivers(soap, tag?tag:"-ns1:GetDrivers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDrivers * SOAP_FMAC4 soap_get___ns1__GetDrivers(struct soap *soap, struct __ns1__GetDrivers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDrivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetDrivers * SOAP_FMAC2 soap_instantiate___ns1__GetDrivers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDrivers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetDrivers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDrivers);
		if (size)
			*size = sizeof(struct __ns1__GetDrivers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDrivers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetDrivers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetDrivers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDrivers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDrivers %p -> %p\n", q, p));
	*(struct __ns1__GetDrivers*)p = *(struct __ns1__GetDrivers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDevices(struct soap *soap, struct __ns1__GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDevices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDevices(struct soap *soap, const struct __ns1__GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDevices(soap, &a->ns1__GetDevices);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDevices(struct soap *soap, const char *tag, int id, const struct __ns1__GetDevices *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDevices(soap, "ns1:GetDevices", -1, &a->ns1__GetDevices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevices * SOAP_FMAC4 soap_in___ns1__GetDevices(struct soap *soap, const char *tag, struct __ns1__GetDevices *a, const char *type)
{
	size_t soap_flag_ns1__GetDevices = 1;
	short soap_flag;
	a = (struct __ns1__GetDevices *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDevices, sizeof(struct __ns1__GetDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDevices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDevices && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDevices(soap, "ns1:GetDevices", &a->ns1__GetDevices, ""))
				{	soap_flag_ns1__GetDevices--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDevices(struct soap *soap, const struct __ns1__GetDevices *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDevices(soap, tag?tag:"-ns1:GetDevices", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevices * SOAP_FMAC4 soap_get___ns1__GetDevices(struct soap *soap, struct __ns1__GetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetDevices * SOAP_FMAC2 soap_instantiate___ns1__GetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDevices);
		if (size)
			*size = sizeof(struct __ns1__GetDevices);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDevices[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetDevices);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetDevices*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDevices %p -> %p\n", q, p));
	*(struct __ns1__GetDevices*)p = *(struct __ns1__GetDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBoardInfo(struct soap *soap, struct __ns1__GetBoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBoardInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBoardInfo(struct soap *soap, const struct __ns1__GetBoardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetBoardInfo(soap, &a->ns1__GetBoardInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetBoardInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetBoardInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetBoardInfo(soap, "ns1:GetBoardInfo", -1, &a->ns1__GetBoardInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBoardInfo * SOAP_FMAC4 soap_in___ns1__GetBoardInfo(struct soap *soap, const char *tag, struct __ns1__GetBoardInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetBoardInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetBoardInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBoardInfo, sizeof(struct __ns1__GetBoardInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetBoardInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBoardInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetBoardInfo(soap, "ns1:GetBoardInfo", &a->ns1__GetBoardInfo, ""))
				{	soap_flag_ns1__GetBoardInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBoardInfo(struct soap *soap, const struct __ns1__GetBoardInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetBoardInfo(soap, tag?tag:"-ns1:GetBoardInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBoardInfo * SOAP_FMAC4 soap_get___ns1__GetBoardInfo(struct soap *soap, struct __ns1__GetBoardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetBoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBoardInfo * SOAP_FMAC2 soap_instantiate___ns1__GetBoardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBoardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBoardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBoardInfo);
		if (size)
			*size = sizeof(struct __ns1__GetBoardInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBoardInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetBoardInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBoardInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBoardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBoardInfo %p -> %p\n", q, p));
	*(struct __ns1__GetBoardInfo*)p = *(struct __ns1__GetBoardInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StopProgram(struct soap *soap, struct __ns1__StopProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopProgram = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StopProgram(struct soap *soap, const struct __ns1__StopProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopProgram(soap, &a->ns1__StopProgram);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StopProgram(struct soap *soap, const char *tag, int id, const struct __ns1__StopProgram *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopProgram(soap, "ns1:StopProgram", -1, &a->ns1__StopProgram, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopProgram * SOAP_FMAC4 soap_in___ns1__StopProgram(struct soap *soap, const char *tag, struct __ns1__StopProgram *a, const char *type)
{
	size_t soap_flag_ns1__StopProgram = 1;
	short soap_flag;
	a = (struct __ns1__StopProgram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__StopProgram, sizeof(struct __ns1__StopProgram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StopProgram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopProgram && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopProgram(soap, "ns1:StopProgram", &a->ns1__StopProgram, ""))
				{	soap_flag_ns1__StopProgram--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StopProgram(struct soap *soap, const struct __ns1__StopProgram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StopProgram(soap, tag?tag:"-ns1:StopProgram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopProgram * SOAP_FMAC4 soap_get___ns1__StopProgram(struct soap *soap, struct __ns1__StopProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StopProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StopProgram * SOAP_FMAC2 soap_instantiate___ns1__StopProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StopProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__StopProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StopProgram);
		if (size)
			*size = sizeof(struct __ns1__StopProgram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StopProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__StopProgram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__StopProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StopProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StopProgram %p -> %p\n", q, p));
	*(struct __ns1__StopProgram*)p = *(struct __ns1__StopProgram*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StartProgram(struct soap *soap, struct __ns1__StartProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartProgram = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StartProgram(struct soap *soap, const struct __ns1__StartProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StartProgram(soap, &a->ns1__StartProgram);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StartProgram(struct soap *soap, const char *tag, int id, const struct __ns1__StartProgram *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StartProgram(soap, "ns1:StartProgram", -1, &a->ns1__StartProgram, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartProgram * SOAP_FMAC4 soap_in___ns1__StartProgram(struct soap *soap, const char *tag, struct __ns1__StartProgram *a, const char *type)
{
	size_t soap_flag_ns1__StartProgram = 1;
	short soap_flag;
	a = (struct __ns1__StartProgram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__StartProgram, sizeof(struct __ns1__StartProgram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StartProgram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartProgram && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartProgram(soap, "ns1:StartProgram", &a->ns1__StartProgram, ""))
				{	soap_flag_ns1__StartProgram--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StartProgram(struct soap *soap, const struct __ns1__StartProgram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StartProgram(soap, tag?tag:"-ns1:StartProgram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StartProgram * SOAP_FMAC4 soap_get___ns1__StartProgram(struct soap *soap, struct __ns1__StartProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StartProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StartProgram * SOAP_FMAC2 soap_instantiate___ns1__StartProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StartProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__StartProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StartProgram);
		if (size)
			*size = sizeof(struct __ns1__StartProgram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StartProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__StartProgram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__StartProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StartProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StartProgram %p -> %p\n", q, p));
	*(struct __ns1__StartProgram*)p = *(struct __ns1__StartProgram*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddProgram(struct soap *soap, struct __ns1__AddProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddProgram = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddProgram(struct soap *soap, const struct __ns1__AddProgram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddProgram(soap, &a->ns1__AddProgram);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddProgram(struct soap *soap, const char *tag, int id, const struct __ns1__AddProgram *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddProgram(soap, "ns1:AddProgram", -1, &a->ns1__AddProgram, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddProgram * SOAP_FMAC4 soap_in___ns1__AddProgram(struct soap *soap, const char *tag, struct __ns1__AddProgram *a, const char *type)
{
	size_t soap_flag_ns1__AddProgram = 1;
	short soap_flag;
	a = (struct __ns1__AddProgram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AddProgram, sizeof(struct __ns1__AddProgram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddProgram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddProgram && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddProgram(soap, "ns1:AddProgram", &a->ns1__AddProgram, ""))
				{	soap_flag_ns1__AddProgram--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddProgram(struct soap *soap, const struct __ns1__AddProgram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__AddProgram(soap, tag?tag:"-ns1:AddProgram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddProgram * SOAP_FMAC4 soap_get___ns1__AddProgram(struct soap *soap, struct __ns1__AddProgram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__AddProgram * SOAP_FMAC2 soap_instantiate___ns1__AddProgram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddProgram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__AddProgram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AddProgram);
		if (size)
			*size = sizeof(struct __ns1__AddProgram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AddProgram[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__AddProgram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__AddProgram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__AddProgram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__AddProgram %p -> %p\n", q, p));
	*(struct __ns1__AddProgram*)p = *(struct __ns1__AddProgram*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRunningProgramsStatusResponse(struct soap *soap, _ns1__GetRunningProgramsStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRunningProgramsStatusResponse(struct soap *soap, const char *tag, int id, _ns1__GetRunningProgramsStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRunningProgramsStatusResponse(struct soap *soap, const char *tag, _ns1__GetRunningProgramsStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRunningProgramsStatusResponse **)soap_malloc(soap, sizeof(_ns1__GetRunningProgramsStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRunningProgramsStatusResponse *)soap_instantiate__ns1__GetRunningProgramsStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetRunningProgramsStatusResponse ** p = (_ns1__GetRunningProgramsStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRunningProgramsStatusResponse, sizeof(_ns1__GetRunningProgramsStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRunningProgramsStatusResponse(struct soap *soap, _ns1__GetRunningProgramsStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatusResponse);
	if (soap_out_PointerTo_ns1__GetRunningProgramsStatusResponse(soap, tag?tag:"ns1:GetRunningProgramsStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRunningProgramsStatusResponse(struct soap *soap, _ns1__GetRunningProgramsStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRunningProgramsStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRunningProgramsStatus(struct soap *soap, _ns1__GetRunningProgramsStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRunningProgramsStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, int id, _ns1__GetRunningProgramsStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRunningProgramsStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRunningProgramsStatus(struct soap *soap, const char *tag, _ns1__GetRunningProgramsStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRunningProgramsStatus **)soap_malloc(soap, sizeof(_ns1__GetRunningProgramsStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRunningProgramsStatus *)soap_instantiate__ns1__GetRunningProgramsStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetRunningProgramsStatus ** p = (_ns1__GetRunningProgramsStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRunningProgramsStatus, sizeof(_ns1__GetRunningProgramsStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRunningProgramsStatus(struct soap *soap, _ns1__GetRunningProgramsStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetRunningProgramsStatus);
	if (soap_out_PointerTo_ns1__GetRunningProgramsStatus(soap, tag?tag:"ns1:GetRunningProgramsStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRunningProgramsStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRunningProgramsStatus(struct soap *soap, _ns1__GetRunningProgramsStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRunningProgramsStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProgramStatusResponse(struct soap *soap, _ns1__GetProgramStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProgramStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProgramStatusResponse(struct soap *soap, const char *tag, int id, _ns1__GetProgramStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProgramStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProgramStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProgramStatusResponse(struct soap *soap, const char *tag, _ns1__GetProgramStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProgramStatusResponse **)soap_malloc(soap, sizeof(_ns1__GetProgramStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProgramStatusResponse *)soap_instantiate__ns1__GetProgramStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetProgramStatusResponse ** p = (_ns1__GetProgramStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProgramStatusResponse, sizeof(_ns1__GetProgramStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProgramStatusResponse(struct soap *soap, _ns1__GetProgramStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProgramStatusResponse);
	if (soap_out_PointerTo_ns1__GetProgramStatusResponse(soap, tag?tag:"ns1:GetProgramStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetProgramStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProgramStatusResponse(struct soap *soap, _ns1__GetProgramStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProgramStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProgramStatus(struct soap *soap, _ns1__GetProgramStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProgramStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProgramStatus(struct soap *soap, const char *tag, int id, _ns1__GetProgramStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProgramStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProgramStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProgramStatus(struct soap *soap, const char *tag, _ns1__GetProgramStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProgramStatus **)soap_malloc(soap, sizeof(_ns1__GetProgramStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProgramStatus *)soap_instantiate__ns1__GetProgramStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetProgramStatus ** p = (_ns1__GetProgramStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProgramStatus, sizeof(_ns1__GetProgramStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProgramStatus(struct soap *soap, _ns1__GetProgramStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProgramStatus);
	if (soap_out_PointerTo_ns1__GetProgramStatus(soap, tag?tag:"ns1:GetProgramStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetProgramStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProgramStatus(struct soap *soap, _ns1__GetProgramStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProgramStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProgramResponse(struct soap *soap, _ns1__GetProgramResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProgramResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProgramResponse(struct soap *soap, const char *tag, int id, _ns1__GetProgramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProgramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProgramResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProgramResponse(struct soap *soap, const char *tag, _ns1__GetProgramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProgramResponse **)soap_malloc(soap, sizeof(_ns1__GetProgramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProgramResponse *)soap_instantiate__ns1__GetProgramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetProgramResponse ** p = (_ns1__GetProgramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProgramResponse, sizeof(_ns1__GetProgramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProgramResponse(struct soap *soap, _ns1__GetProgramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProgramResponse);
	if (soap_out_PointerTo_ns1__GetProgramResponse(soap, tag?tag:"ns1:GetProgramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetProgramResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProgramResponse(struct soap *soap, _ns1__GetProgramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProgram(struct soap *soap, _ns1__GetProgram *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProgram))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProgram(struct soap *soap, const char *tag, int id, _ns1__GetProgram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProgram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProgram ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProgram(struct soap *soap, const char *tag, _ns1__GetProgram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProgram **)soap_malloc(soap, sizeof(_ns1__GetProgram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProgram *)soap_instantiate__ns1__GetProgram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetProgram ** p = (_ns1__GetProgram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProgram, sizeof(_ns1__GetProgram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProgram(struct soap *soap, _ns1__GetProgram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProgram);
	if (soap_out_PointerTo_ns1__GetProgram(soap, tag?tag:"ns1:GetProgram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetProgram ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProgram(struct soap *soap, _ns1__GetProgram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProgramsResponse(struct soap *soap, _ns1__GetProgramsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProgramsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProgramsResponse(struct soap *soap, const char *tag, int id, _ns1__GetProgramsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProgramsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProgramsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProgramsResponse(struct soap *soap, const char *tag, _ns1__GetProgramsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProgramsResponse **)soap_malloc(soap, sizeof(_ns1__GetProgramsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProgramsResponse *)soap_instantiate__ns1__GetProgramsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetProgramsResponse ** p = (_ns1__GetProgramsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProgramsResponse, sizeof(_ns1__GetProgramsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProgramsResponse(struct soap *soap, _ns1__GetProgramsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProgramsResponse);
	if (soap_out_PointerTo_ns1__GetProgramsResponse(soap, tag?tag:"ns1:GetProgramsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetProgramsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProgramsResponse(struct soap *soap, _ns1__GetProgramsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProgramsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPrograms(struct soap *soap, _ns1__GetPrograms *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPrograms))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPrograms(struct soap *soap, const char *tag, int id, _ns1__GetPrograms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPrograms);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPrograms ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPrograms(struct soap *soap, const char *tag, _ns1__GetPrograms **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPrograms **)soap_malloc(soap, sizeof(_ns1__GetPrograms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPrograms *)soap_instantiate__ns1__GetPrograms(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPrograms ** p = (_ns1__GetPrograms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPrograms, sizeof(_ns1__GetPrograms), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPrograms(struct soap *soap, _ns1__GetPrograms *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPrograms);
	if (soap_out_PointerTo_ns1__GetPrograms(soap, tag?tag:"ns1:GetPrograms", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPrograms ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPrograms(struct soap *soap, _ns1__GetPrograms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPrograms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDriversResponse(struct soap *soap, _ns1__GetDriversResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDriversResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDriversResponse(struct soap *soap, const char *tag, int id, _ns1__GetDriversResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDriversResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDriversResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDriversResponse(struct soap *soap, const char *tag, _ns1__GetDriversResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDriversResponse **)soap_malloc(soap, sizeof(_ns1__GetDriversResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDriversResponse *)soap_instantiate__ns1__GetDriversResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDriversResponse ** p = (_ns1__GetDriversResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDriversResponse, sizeof(_ns1__GetDriversResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDriversResponse(struct soap *soap, _ns1__GetDriversResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDriversResponse);
	if (soap_out_PointerTo_ns1__GetDriversResponse(soap, tag?tag:"ns1:GetDriversResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDriversResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDriversResponse(struct soap *soap, _ns1__GetDriversResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDriversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDrivers(struct soap *soap, _ns1__GetDrivers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDrivers))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDrivers(struct soap *soap, const char *tag, int id, _ns1__GetDrivers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDrivers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDrivers ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDrivers(struct soap *soap, const char *tag, _ns1__GetDrivers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDrivers **)soap_malloc(soap, sizeof(_ns1__GetDrivers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDrivers *)soap_instantiate__ns1__GetDrivers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDrivers ** p = (_ns1__GetDrivers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDrivers, sizeof(_ns1__GetDrivers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDrivers(struct soap *soap, _ns1__GetDrivers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDrivers);
	if (soap_out_PointerTo_ns1__GetDrivers(soap, tag?tag:"ns1:GetDrivers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDrivers ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDrivers(struct soap *soap, _ns1__GetDrivers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDrivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDevicesResponse(struct soap *soap, _ns1__GetDevicesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDevicesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDevicesResponse(struct soap *soap, const char *tag, int id, _ns1__GetDevicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDevicesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDevicesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDevicesResponse(struct soap *soap, const char *tag, _ns1__GetDevicesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDevicesResponse **)soap_malloc(soap, sizeof(_ns1__GetDevicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDevicesResponse *)soap_instantiate__ns1__GetDevicesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDevicesResponse ** p = (_ns1__GetDevicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDevicesResponse, sizeof(_ns1__GetDevicesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDevicesResponse(struct soap *soap, _ns1__GetDevicesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDevicesResponse);
	if (soap_out_PointerTo_ns1__GetDevicesResponse(soap, tag?tag:"ns1:GetDevicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDevicesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDevicesResponse(struct soap *soap, _ns1__GetDevicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDevices(struct soap *soap, _ns1__GetDevices *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDevices))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDevices(struct soap *soap, const char *tag, int id, _ns1__GetDevices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDevices);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDevices ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDevices(struct soap *soap, const char *tag, _ns1__GetDevices **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDevices **)soap_malloc(soap, sizeof(_ns1__GetDevices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDevices *)soap_instantiate__ns1__GetDevices(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDevices ** p = (_ns1__GetDevices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDevices, sizeof(_ns1__GetDevices), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDevices(struct soap *soap, _ns1__GetDevices *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDevices);
	if (soap_out_PointerTo_ns1__GetDevices(soap, tag?tag:"ns1:GetDevices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDevices ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDevices(struct soap *soap, _ns1__GetDevices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBoardInfoResponse(struct soap *soap, _ns1__GetBoardInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBoardInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBoardInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetBoardInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBoardInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBoardInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBoardInfoResponse(struct soap *soap, const char *tag, _ns1__GetBoardInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBoardInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetBoardInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBoardInfoResponse *)soap_instantiate__ns1__GetBoardInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBoardInfoResponse ** p = (_ns1__GetBoardInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBoardInfoResponse, sizeof(_ns1__GetBoardInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBoardInfoResponse(struct soap *soap, _ns1__GetBoardInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBoardInfoResponse);
	if (soap_out_PointerTo_ns1__GetBoardInfoResponse(soap, tag?tag:"ns1:GetBoardInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBoardInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBoardInfoResponse(struct soap *soap, _ns1__GetBoardInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBoardInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBoardInfo(struct soap *soap, _ns1__GetBoardInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBoardInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBoardInfo(struct soap *soap, const char *tag, int id, _ns1__GetBoardInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBoardInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBoardInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBoardInfo(struct soap *soap, const char *tag, _ns1__GetBoardInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBoardInfo **)soap_malloc(soap, sizeof(_ns1__GetBoardInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBoardInfo *)soap_instantiate__ns1__GetBoardInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBoardInfo ** p = (_ns1__GetBoardInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBoardInfo, sizeof(_ns1__GetBoardInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBoardInfo(struct soap *soap, _ns1__GetBoardInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBoardInfo);
	if (soap_out_PointerTo_ns1__GetBoardInfo(soap, tag?tag:"ns1:GetBoardInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBoardInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBoardInfo(struct soap *soap, _ns1__GetBoardInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBoardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopProgramResponse(struct soap *soap, _ns1__StopProgramResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopProgramResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopProgramResponse(struct soap *soap, const char *tag, int id, _ns1__StopProgramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopProgramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopProgramResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopProgramResponse(struct soap *soap, const char *tag, _ns1__StopProgramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopProgramResponse **)soap_malloc(soap, sizeof(_ns1__StopProgramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopProgramResponse *)soap_instantiate__ns1__StopProgramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopProgramResponse ** p = (_ns1__StopProgramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopProgramResponse, sizeof(_ns1__StopProgramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopProgramResponse(struct soap *soap, _ns1__StopProgramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopProgramResponse);
	if (soap_out_PointerTo_ns1__StopProgramResponse(soap, tag?tag:"ns1:StopProgramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopProgramResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopProgramResponse(struct soap *soap, _ns1__StopProgramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopProgram(struct soap *soap, _ns1__StopProgram *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopProgram))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopProgram(struct soap *soap, const char *tag, int id, _ns1__StopProgram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopProgram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopProgram ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopProgram(struct soap *soap, const char *tag, _ns1__StopProgram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopProgram **)soap_malloc(soap, sizeof(_ns1__StopProgram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopProgram *)soap_instantiate__ns1__StopProgram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopProgram ** p = (_ns1__StopProgram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopProgram, sizeof(_ns1__StopProgram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopProgram(struct soap *soap, _ns1__StopProgram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopProgram);
	if (soap_out_PointerTo_ns1__StopProgram(soap, tag?tag:"ns1:StopProgram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopProgram ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopProgram(struct soap *soap, _ns1__StopProgram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartProgramResponse(struct soap *soap, _ns1__StartProgramResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartProgramResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartProgramResponse(struct soap *soap, const char *tag, int id, _ns1__StartProgramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartProgramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartProgramResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartProgramResponse(struct soap *soap, const char *tag, _ns1__StartProgramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartProgramResponse **)soap_malloc(soap, sizeof(_ns1__StartProgramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartProgramResponse *)soap_instantiate__ns1__StartProgramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StartProgramResponse ** p = (_ns1__StartProgramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartProgramResponse, sizeof(_ns1__StartProgramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartProgramResponse(struct soap *soap, _ns1__StartProgramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StartProgramResponse);
	if (soap_out_PointerTo_ns1__StartProgramResponse(soap, tag?tag:"ns1:StartProgramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StartProgramResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartProgramResponse(struct soap *soap, _ns1__StartProgramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartProgram(struct soap *soap, _ns1__StartProgram *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartProgram))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartProgram(struct soap *soap, const char *tag, int id, _ns1__StartProgram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartProgram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartProgram ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartProgram(struct soap *soap, const char *tag, _ns1__StartProgram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartProgram **)soap_malloc(soap, sizeof(_ns1__StartProgram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartProgram *)soap_instantiate__ns1__StartProgram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StartProgram ** p = (_ns1__StartProgram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartProgram, sizeof(_ns1__StartProgram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartProgram(struct soap *soap, _ns1__StartProgram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StartProgram);
	if (soap_out_PointerTo_ns1__StartProgram(soap, tag?tag:"ns1:StartProgram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StartProgram ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartProgram(struct soap *soap, _ns1__StartProgram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddProgramResponse(struct soap *soap, _ns1__AddProgramResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddProgramResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddProgramResponse(struct soap *soap, const char *tag, int id, _ns1__AddProgramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddProgramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddProgramResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddProgramResponse(struct soap *soap, const char *tag, _ns1__AddProgramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddProgramResponse **)soap_malloc(soap, sizeof(_ns1__AddProgramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddProgramResponse *)soap_instantiate__ns1__AddProgramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddProgramResponse ** p = (_ns1__AddProgramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddProgramResponse, sizeof(_ns1__AddProgramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddProgramResponse(struct soap *soap, _ns1__AddProgramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddProgramResponse);
	if (soap_out_PointerTo_ns1__AddProgramResponse(soap, tag?tag:"ns1:AddProgramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddProgramResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddProgramResponse(struct soap *soap, _ns1__AddProgramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddProgramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddProgram(struct soap *soap, _ns1__AddProgram *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddProgram))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddProgram(struct soap *soap, const char *tag, int id, _ns1__AddProgram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddProgram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddProgram ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddProgram(struct soap *soap, const char *tag, _ns1__AddProgram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddProgram **)soap_malloc(soap, sizeof(_ns1__AddProgram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddProgram *)soap_instantiate__ns1__AddProgram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddProgram ** p = (_ns1__AddProgram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddProgram, sizeof(_ns1__AddProgram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddProgram(struct soap *soap, _ns1__AddProgram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddProgram);
	if (soap_out_PointerTo_ns1__AddProgram(soap, tag?tag:"ns1:AddProgram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddProgram ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddProgram(struct soap *soap, _ns1__AddProgram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddProgram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, ns1__ArrayOfSoapConnectionPointDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapConnectionPointDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapConnectionPointDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapConnectionPointDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapConnectionPointDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapConnectionPointDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapConnectionPointDescriptor *)soap_instantiate_ns1__ArrayOfSoapConnectionPointDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapConnectionPointDescriptor ** p = (ns1__ArrayOfSoapConnectionPointDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapConnectionPointDescriptor, sizeof(ns1__ArrayOfSoapConnectionPointDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, ns1__ArrayOfSoapConnectionPointDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapConnectionPointDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, tag?tag:"ns1:ArrayOfSoapConnectionPointDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapConnectionPointDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapConnectionPointDescriptor(struct soap *soap, ns1__ArrayOfSoapConnectionPointDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapConnectionPointDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, ns1__ArrayOfSoapWireConnectionPointDescr *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapWireConnectionPointDescr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireConnectionPointDescr ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, const char *tag, ns1__ArrayOfSoapWireConnectionPointDescr **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapWireConnectionPointDescr **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapWireConnectionPointDescr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapWireConnectionPointDescr *)soap_instantiate_ns1__ArrayOfSoapWireConnectionPointDescr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapWireConnectionPointDescr ** p = (ns1__ArrayOfSoapWireConnectionPointDescr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapWireConnectionPointDescr, sizeof(ns1__ArrayOfSoapWireConnectionPointDescr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, ns1__ArrayOfSoapWireConnectionPointDescr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapWireConnectionPointDescr);
	if (soap_out_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, tag?tag:"ns1:ArrayOfSoapWireConnectionPointDescr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireConnectionPointDescr ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapWireConnectionPointDescr(struct soap *soap, ns1__ArrayOfSoapWireConnectionPointDescr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapWireConnectionPointDescr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapEventParameterDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapEventParameterDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventParameterDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapEventParameterDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapEventParameterDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapEventParameterDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapEventParameterDescriptor *)soap_instantiate_ns1__ArrayOfSoapEventParameterDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapEventParameterDescriptor ** p = (ns1__ArrayOfSoapEventParameterDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapEventParameterDescriptor, sizeof(ns1__ArrayOfSoapEventParameterDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapEventParameterDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapEventParameterDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, tag?tag:"ns1:ArrayOfSoapEventParameterDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventParameterDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapEventParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapEventParameterDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapEventParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandParameterDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapCommandParameterDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandParameterDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapCommandParameterDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapCommandParameterDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapCommandParameterDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapCommandParameterDescriptor *)soap_instantiate_ns1__ArrayOfSoapCommandParameterDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapCommandParameterDescriptor ** p = (ns1__ArrayOfSoapCommandParameterDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapCommandParameterDescriptor, sizeof(ns1__ArrayOfSoapCommandParameterDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandParameterDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapCommandParameterDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, tag?tag:"ns1:ArrayOfSoapCommandParameterDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandParameterDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapCommandParameterDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandParameterDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapCommandParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapEventDescriptor(struct soap *soap, ns1__ArrayOfSoapEventDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapEventDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapEventDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapEventDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapEventDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapEventDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapEventDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapEventDescriptor *)soap_instantiate_ns1__ArrayOfSoapEventDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapEventDescriptor ** p = (ns1__ArrayOfSoapEventDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapEventDescriptor, sizeof(ns1__ArrayOfSoapEventDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapEventDescriptor(struct soap *soap, ns1__ArrayOfSoapEventDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapEventDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapEventDescriptor(soap, tag?tag:"ns1:ArrayOfSoapEventDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapEventDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapEventDescriptor(struct soap *soap, ns1__ArrayOfSoapEventDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapEventDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapCommandDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapCommandDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapCommandDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapCommandDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapCommandDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapCommandDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapCommandDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapCommandDescriptor *)soap_instantiate_ns1__ArrayOfSoapCommandDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapCommandDescriptor ** p = (ns1__ArrayOfSoapCommandDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapCommandDescriptor, sizeof(ns1__ArrayOfSoapCommandDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapCommandDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapCommandDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapCommandDescriptor(soap, tag?tag:"ns1:ArrayOfSoapCommandDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapCommandDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapCommandDescriptor(struct soap *soap, ns1__ArrayOfSoapCommandDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapCommandDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapPinoutDescriptor(struct soap *soap, ns1__ArrayOfSoapPinoutDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapPinoutDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapPinoutDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPinoutDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapPinoutDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapPinoutDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapPinoutDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapPinoutDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapPinoutDescriptor *)soap_instantiate_ns1__ArrayOfSoapPinoutDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapPinoutDescriptor ** p = (ns1__ArrayOfSoapPinoutDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapPinoutDescriptor, sizeof(ns1__ArrayOfSoapPinoutDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapPinoutDescriptor(struct soap *soap, ns1__ArrayOfSoapPinoutDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapPinoutDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, tag?tag:"ns1:ArrayOfSoapPinoutDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapPinoutDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapPinoutDescriptor(struct soap *soap, ns1__ArrayOfSoapPinoutDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapPinoutDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapWireDescriptor(struct soap *soap, ns1__ArrayOfSoapWireDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapWireDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapWireDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapWireDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapWireDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapWireDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapWireDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapWireDescriptor *)soap_instantiate_ns1__ArrayOfSoapWireDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapWireDescriptor ** p = (ns1__ArrayOfSoapWireDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapWireDescriptor, sizeof(ns1__ArrayOfSoapWireDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapWireDescriptor(struct soap *soap, ns1__ArrayOfSoapWireDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapWireDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapWireDescriptor(soap, tag?tag:"ns1:ArrayOfSoapWireDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapWireDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapWireDescriptor(struct soap *soap, ns1__ArrayOfSoapWireDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapWireDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapProgramDescriptor(struct soap *soap, ns1__ArrayOfSoapProgramDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapProgramDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapProgramDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapProgramDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapProgramDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapProgramDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapProgramDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapProgramDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapProgramDescriptor *)soap_instantiate_ns1__ArrayOfSoapProgramDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapProgramDescriptor ** p = (ns1__ArrayOfSoapProgramDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapProgramDescriptor, sizeof(ns1__ArrayOfSoapProgramDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapProgramDescriptor(struct soap *soap, ns1__ArrayOfSoapProgramDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapProgramDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapProgramDescriptor(soap, tag?tag:"ns1:ArrayOfSoapProgramDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapProgramDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapProgramDescriptor(struct soap *soap, ns1__ArrayOfSoapProgramDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapProgramDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapDriverDescriptor(struct soap *soap, ns1__ArrayOfSoapDriverDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapDriverDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapDriverDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDriverDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapDriverDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapDriverDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapDriverDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapDriverDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapDriverDescriptor *)soap_instantiate_ns1__ArrayOfSoapDriverDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapDriverDescriptor ** p = (ns1__ArrayOfSoapDriverDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapDriverDescriptor, sizeof(ns1__ArrayOfSoapDriverDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapDriverDescriptor(struct soap *soap, ns1__ArrayOfSoapDriverDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapDriverDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapDriverDescriptor(soap, tag?tag:"ns1:ArrayOfSoapDriverDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapDriverDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapDriverDescriptor(struct soap *soap, ns1__ArrayOfSoapDriverDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapDriverDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapDeviceDescriptor(struct soap *soap, ns1__ArrayOfSoapDeviceDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapDeviceDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapDeviceDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapDeviceDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapDeviceDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapDeviceDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapDeviceDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapDeviceDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapDeviceDescriptor *)soap_instantiate_ns1__ArrayOfSoapDeviceDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapDeviceDescriptor ** p = (ns1__ArrayOfSoapDeviceDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapDeviceDescriptor, sizeof(ns1__ArrayOfSoapDeviceDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapDeviceDescriptor(struct soap *soap, ns1__ArrayOfSoapDeviceDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapDeviceDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, tag?tag:"ns1:ArrayOfSoapDeviceDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapDeviceDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapDeviceDescriptor(struct soap *soap, ns1__ArrayOfSoapDeviceDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapDeviceDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapProgramMappingDescriptor(struct soap *soap, ns1__SoapProgramMappingDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapProgramMappingDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapProgramMappingDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapProgramMappingDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapProgramMappingDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapProgramMappingDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapProgramMappingDescriptor(struct soap *soap, const char *tag, ns1__SoapProgramMappingDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapProgramMappingDescriptor **)soap_malloc(soap, sizeof(ns1__SoapProgramMappingDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapProgramMappingDescriptor *)soap_instantiate_ns1__SoapProgramMappingDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapProgramMappingDescriptor ** p = (ns1__SoapProgramMappingDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapProgramMappingDescriptor, sizeof(ns1__SoapProgramMappingDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapProgramMappingDescriptor(struct soap *soap, ns1__SoapProgramMappingDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapProgramMappingDescriptor);
	if (soap_out_PointerTons1__SoapProgramMappingDescriptor(soap, tag?tag:"ns1:SoapProgramMappingDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapProgramMappingDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapProgramMappingDescriptor(struct soap *soap, ns1__SoapProgramMappingDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapProgramMappingDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapProgramDescriptor(struct soap *soap, ns1__SoapProgramDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapProgramDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapProgramDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapProgramDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapProgramDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapProgramDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapProgramDescriptor(struct soap *soap, const char *tag, ns1__SoapProgramDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapProgramDescriptor **)soap_malloc(soap, sizeof(ns1__SoapProgramDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapProgramDescriptor *)soap_instantiate_ns1__SoapProgramDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapProgramDescriptor ** p = (ns1__SoapProgramDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapProgramDescriptor, sizeof(ns1__SoapProgramDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapProgramDescriptor(struct soap *soap, ns1__SoapProgramDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapProgramDescriptor);
	if (soap_out_PointerTons1__SoapProgramDescriptor(soap, tag?tag:"ns1:SoapProgramDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapProgramDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapProgramDescriptor(struct soap *soap, ns1__SoapProgramDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapProgramDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapDriverDescriptor(struct soap *soap, ns1__SoapDriverDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapDriverDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapDriverDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapDriverDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapDriverDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapDriverDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapDriverDescriptor(struct soap *soap, const char *tag, ns1__SoapDriverDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapDriverDescriptor **)soap_malloc(soap, sizeof(ns1__SoapDriverDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapDriverDescriptor *)soap_instantiate_ns1__SoapDriverDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapDriverDescriptor ** p = (ns1__SoapDriverDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapDriverDescriptor, sizeof(ns1__SoapDriverDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapDriverDescriptor(struct soap *soap, ns1__SoapDriverDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapDriverDescriptor);
	if (soap_out_PointerTons1__SoapDriverDescriptor(soap, tag?tag:"ns1:SoapDriverDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapDriverDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapDriverDescriptor(struct soap *soap, ns1__SoapDriverDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapDriverDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapWireDescriptor(struct soap *soap, ns1__SoapWireDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapWireDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapWireDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapWireDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapWireDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapWireDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapWireDescriptor(struct soap *soap, const char *tag, ns1__SoapWireDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapWireDescriptor **)soap_malloc(soap, sizeof(ns1__SoapWireDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapWireDescriptor *)soap_instantiate_ns1__SoapWireDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapWireDescriptor ** p = (ns1__SoapWireDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapWireDescriptor, sizeof(ns1__SoapWireDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapWireDescriptor(struct soap *soap, ns1__SoapWireDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapWireDescriptor);
	if (soap_out_PointerTons1__SoapWireDescriptor(soap, tag?tag:"ns1:SoapWireDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapWireDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapWireDescriptor(struct soap *soap, ns1__SoapWireDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapWireDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapDeviceDescriptor(struct soap *soap, ns1__SoapDeviceDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapDeviceDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapDeviceDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapDeviceDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapDeviceDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapDeviceDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapDeviceDescriptor(struct soap *soap, const char *tag, ns1__SoapDeviceDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapDeviceDescriptor **)soap_malloc(soap, sizeof(ns1__SoapDeviceDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapDeviceDescriptor *)soap_instantiate_ns1__SoapDeviceDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapDeviceDescriptor ** p = (ns1__SoapDeviceDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapDeviceDescriptor, sizeof(ns1__SoapDeviceDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapDeviceDescriptor(struct soap *soap, ns1__SoapDeviceDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapDeviceDescriptor);
	if (soap_out_PointerTons1__SoapDeviceDescriptor(soap, tag?tag:"ns1:SoapDeviceDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapDeviceDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapDeviceDescriptor(struct soap *soap, ns1__SoapDeviceDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapDeviceDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapConnectionPointDescriptor(struct soap *soap, ns1__SoapConnectionPointDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapConnectionPointDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapConnectionPointDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapConnectionPointDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapConnectionPointDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, ns1__SoapConnectionPointDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapConnectionPointDescriptor **)soap_malloc(soap, sizeof(ns1__SoapConnectionPointDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapConnectionPointDescriptor *)soap_instantiate_ns1__SoapConnectionPointDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapConnectionPointDescriptor ** p = (ns1__SoapConnectionPointDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapConnectionPointDescriptor, sizeof(ns1__SoapConnectionPointDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapConnectionPointDescriptor(struct soap *soap, ns1__SoapConnectionPointDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapConnectionPointDescriptor);
	if (soap_out_PointerTons1__SoapConnectionPointDescriptor(soap, tag?tag:"ns1:SoapConnectionPointDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapConnectionPointDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapConnectionPointDescriptor(struct soap *soap, ns1__SoapConnectionPointDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapConnectionPointDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapWireConnectionPointDescr(struct soap *soap, ns1__SoapWireConnectionPointDescr *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapWireConnectionPointDescr))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, int id, ns1__SoapWireConnectionPointDescr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapWireConnectionPointDescr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapWireConnectionPointDescr ** SOAP_FMAC4 soap_in_PointerTons1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, ns1__SoapWireConnectionPointDescr **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapWireConnectionPointDescr **)soap_malloc(soap, sizeof(ns1__SoapWireConnectionPointDescr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapWireConnectionPointDescr *)soap_instantiate_ns1__SoapWireConnectionPointDescr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapWireConnectionPointDescr ** p = (ns1__SoapWireConnectionPointDescr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapWireConnectionPointDescr, sizeof(ns1__SoapWireConnectionPointDescr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapWireConnectionPointDescr(struct soap *soap, ns1__SoapWireConnectionPointDescr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapWireConnectionPointDescr);
	if (soap_out_PointerTons1__SoapWireConnectionPointDescr(soap, tag?tag:"ns1:SoapWireConnectionPointDescr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapWireConnectionPointDescr ** SOAP_FMAC4 soap_get_PointerTons1__SoapWireConnectionPointDescr(struct soap *soap, ns1__SoapWireConnectionPointDescr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapWireConnectionPointDescr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapEventParameterDescriptor(struct soap *soap, ns1__SoapEventParameterDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapEventParameterDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapEventParameterDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapEventParameterDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapEventParameterDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, ns1__SoapEventParameterDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapEventParameterDescriptor **)soap_malloc(soap, sizeof(ns1__SoapEventParameterDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapEventParameterDescriptor *)soap_instantiate_ns1__SoapEventParameterDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapEventParameterDescriptor ** p = (ns1__SoapEventParameterDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapEventParameterDescriptor, sizeof(ns1__SoapEventParameterDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapEventParameterDescriptor(struct soap *soap, ns1__SoapEventParameterDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapEventParameterDescriptor);
	if (soap_out_PointerTons1__SoapEventParameterDescriptor(soap, tag?tag:"ns1:SoapEventParameterDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapEventParameterDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapEventParameterDescriptor(struct soap *soap, ns1__SoapEventParameterDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapEventParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapEventDescriptor(struct soap *soap, ns1__SoapEventDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapEventDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapEventDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapEventDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapEventDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapEventDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapEventDescriptor(struct soap *soap, const char *tag, ns1__SoapEventDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapEventDescriptor **)soap_malloc(soap, sizeof(ns1__SoapEventDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapEventDescriptor *)soap_instantiate_ns1__SoapEventDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapEventDescriptor ** p = (ns1__SoapEventDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapEventDescriptor, sizeof(ns1__SoapEventDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapEventDescriptor(struct soap *soap, ns1__SoapEventDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapEventDescriptor);
	if (soap_out_PointerTons1__SoapEventDescriptor(soap, tag?tag:"ns1:SoapEventDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapEventDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapEventDescriptor(struct soap *soap, ns1__SoapEventDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapEventDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapCommandParameterDescriptor(struct soap *soap, ns1__SoapCommandParameterDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapCommandParameterDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapCommandParameterDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapCommandParameterDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapCommandParameterDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, ns1__SoapCommandParameterDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapCommandParameterDescriptor **)soap_malloc(soap, sizeof(ns1__SoapCommandParameterDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapCommandParameterDescriptor *)soap_instantiate_ns1__SoapCommandParameterDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapCommandParameterDescriptor ** p = (ns1__SoapCommandParameterDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapCommandParameterDescriptor, sizeof(ns1__SoapCommandParameterDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapCommandParameterDescriptor(struct soap *soap, ns1__SoapCommandParameterDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapCommandParameterDescriptor);
	if (soap_out_PointerTons1__SoapCommandParameterDescriptor(soap, tag?tag:"ns1:SoapCommandParameterDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapCommandParameterDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapCommandParameterDescriptor(struct soap *soap, ns1__SoapCommandParameterDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapCommandParameterDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapCommandDescriptor(struct soap *soap, ns1__SoapCommandDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapCommandDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapCommandDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapCommandDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapCommandDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapCommandDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapCommandDescriptor(struct soap *soap, const char *tag, ns1__SoapCommandDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapCommandDescriptor **)soap_malloc(soap, sizeof(ns1__SoapCommandDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapCommandDescriptor *)soap_instantiate_ns1__SoapCommandDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapCommandDescriptor ** p = (ns1__SoapCommandDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapCommandDescriptor, sizeof(ns1__SoapCommandDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapCommandDescriptor(struct soap *soap, ns1__SoapCommandDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapCommandDescriptor);
	if (soap_out_PointerTons1__SoapCommandDescriptor(soap, tag?tag:"ns1:SoapCommandDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapCommandDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapCommandDescriptor(struct soap *soap, ns1__SoapCommandDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapCommandDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapPinoutDescriptor(struct soap *soap, ns1__SoapPinoutDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapPinoutDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapPinoutDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapPinoutDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapPinoutDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapPinoutDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapPinoutDescriptor(struct soap *soap, const char *tag, ns1__SoapPinoutDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapPinoutDescriptor **)soap_malloc(soap, sizeof(ns1__SoapPinoutDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapPinoutDescriptor *)soap_instantiate_ns1__SoapPinoutDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapPinoutDescriptor ** p = (ns1__SoapPinoutDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapPinoutDescriptor, sizeof(ns1__SoapPinoutDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapPinoutDescriptor(struct soap *soap, ns1__SoapPinoutDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapPinoutDescriptor);
	if (soap_out_PointerTons1__SoapPinoutDescriptor(soap, tag?tag:"ns1:SoapPinoutDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapPinoutDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapPinoutDescriptor(struct soap *soap, ns1__SoapPinoutDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapPinoutDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapPropertyDescriptor(struct soap *soap, ns1__SoapPropertyDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapPropertyDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapPropertyDescriptor(struct soap *soap, const char *tag, int id, ns1__SoapPropertyDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapPropertyDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapPropertyDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__SoapPropertyDescriptor(struct soap *soap, const char *tag, ns1__SoapPropertyDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapPropertyDescriptor **)soap_malloc(soap, sizeof(ns1__SoapPropertyDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapPropertyDescriptor *)soap_instantiate_ns1__SoapPropertyDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapPropertyDescriptor ** p = (ns1__SoapPropertyDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapPropertyDescriptor, sizeof(ns1__SoapPropertyDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapPropertyDescriptor(struct soap *soap, ns1__SoapPropertyDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapPropertyDescriptor);
	if (soap_out_PointerTons1__SoapPropertyDescriptor(soap, tag?tag:"ns1:SoapPropertyDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapPropertyDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__SoapPropertyDescriptor(struct soap *soap, ns1__SoapPropertyDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapPropertyDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSoapPropertyDescriptor(struct soap *soap, ns1__ArrayOfSoapPropertyDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(struct soap *soap, const char *tag, int id, ns1__ArrayOfSoapPropertyDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSoapPropertyDescriptor ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(struct soap *soap, const char *tag, ns1__ArrayOfSoapPropertyDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSoapPropertyDescriptor **)soap_malloc(soap, sizeof(ns1__ArrayOfSoapPropertyDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSoapPropertyDescriptor *)soap_instantiate_ns1__ArrayOfSoapPropertyDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfSoapPropertyDescriptor ** p = (ns1__ArrayOfSoapPropertyDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSoapPropertyDescriptor, sizeof(ns1__ArrayOfSoapPropertyDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSoapPropertyDescriptor(struct soap *soap, ns1__ArrayOfSoapPropertyDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfSoapPropertyDescriptor);
	if (soap_out_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, tag?tag:"ns1:ArrayOfSoapPropertyDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSoapPropertyDescriptor ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSoapPropertyDescriptor(struct soap *soap, ns1__ArrayOfSoapPropertyDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSoapPropertyDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, std::vector<ns1__SoapProgramDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, const std::vector<ns1__SoapProgramDescriptor * >*a)
{
	for (std::vector<ns1__SoapProgramDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapProgramDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapProgramDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapProgramDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapProgramDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapProgramDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapProgramDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(soap, -1)))
		return NULL;
	ns1__SoapProgramDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapProgramDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor, sizeof(ns1__SoapProgramDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapProgramDescriptor(soap, tag, NULL, "ns1:SoapProgramDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapProgramDescriptor(soap, tag, &n, "ns1:SoapProgramDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapProgramDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapProgramDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapProgramDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapProgramDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapProgramDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapProgramDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapProgramDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapProgramDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapProgramDescriptor * >*)p = *(std::vector<ns1__SoapProgramDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, std::vector<ns1__SoapDriverDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, const std::vector<ns1__SoapDriverDescriptor * >*a)
{
	for (std::vector<ns1__SoapDriverDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapDriverDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapDriverDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapDriverDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapDriverDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapDriverDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapDriverDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(soap, -1)))
		return NULL;
	ns1__SoapDriverDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapDriverDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor, sizeof(ns1__SoapDriverDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapDriverDescriptor(soap, tag, NULL, "ns1:SoapDriverDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapDriverDescriptor(soap, tag, &n, "ns1:SoapDriverDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapDriverDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapDriverDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapDriverDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapDriverDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapDriverDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapDriverDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapDriverDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapDriverDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapDriverDescriptor * >*)p = *(std::vector<ns1__SoapDriverDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, std::vector<ns1__SoapWireDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, const std::vector<ns1__SoapWireDescriptor * >*a)
{
	for (std::vector<ns1__SoapWireDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapWireDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapWireDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapWireDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapWireDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapWireDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapWireDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(soap, -1)))
		return NULL;
	ns1__SoapWireDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapWireDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireDescriptor, sizeof(ns1__SoapWireDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapWireDescriptor(soap, tag, NULL, "ns1:SoapWireDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapWireDescriptor(soap, tag, &n, "ns1:SoapWireDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapWireDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapWireDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapWireDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapWireDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapWireDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapWireDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapWireDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapWireDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapWireDescriptor * >*)p = *(std::vector<ns1__SoapWireDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, std::vector<ns1__SoapDeviceDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, const std::vector<ns1__SoapDeviceDescriptor * >*a)
{
	for (std::vector<ns1__SoapDeviceDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapDeviceDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapDeviceDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapDeviceDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapDeviceDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapDeviceDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapDeviceDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(soap, -1)))
		return NULL;
	ns1__SoapDeviceDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapDeviceDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor, sizeof(ns1__SoapDeviceDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapDeviceDescriptor(soap, tag, NULL, "ns1:SoapDeviceDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapDeviceDescriptor(soap, tag, &n, "ns1:SoapDeviceDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapDeviceDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapDeviceDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapDeviceDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapDeviceDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapDeviceDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapDeviceDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapDeviceDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapDeviceDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapDeviceDescriptor * >*)p = *(std::vector<ns1__SoapDeviceDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, std::vector<ns1__SoapConnectionPointDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, const std::vector<ns1__SoapConnectionPointDescriptor * >*a)
{
	for (std::vector<ns1__SoapConnectionPointDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapConnectionPointDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapConnectionPointDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapConnectionPointDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapConnectionPointDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapConnectionPointDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapConnectionPointDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(soap, -1)))
		return NULL;
	ns1__SoapConnectionPointDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapConnectionPointDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor, sizeof(ns1__SoapConnectionPointDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapConnectionPointDescriptor(soap, tag, NULL, "ns1:SoapConnectionPointDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapConnectionPointDescriptor(soap, tag, &n, "ns1:SoapConnectionPointDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapConnectionPointDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapConnectionPointDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapConnectionPointDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapConnectionPointDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapConnectionPointDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapConnectionPointDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapConnectionPointDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapConnectionPointDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapConnectionPointDescriptor * >*)p = *(std::vector<ns1__SoapConnectionPointDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, std::vector<ns1__SoapWireConnectionPointDescr * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, const std::vector<ns1__SoapWireConnectionPointDescr * >*a)
{
	for (std::vector<ns1__SoapWireConnectionPointDescr * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapWireConnectionPointDescr(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapWireConnectionPointDescr * >*a, const char *type)
{
	for (std::vector<ns1__SoapWireConnectionPointDescr * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapWireConnectionPointDescr(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapWireConnectionPointDescr * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, const char *tag, std::vector<ns1__SoapWireConnectionPointDescr * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(soap, -1)))
		return NULL;
	ns1__SoapWireConnectionPointDescr *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapWireConnectionPointDescr, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr, sizeof(ns1__SoapWireConnectionPointDescr), 1))
				break;
			if (!soap_in_PointerTons1__SoapWireConnectionPointDescr(soap, tag, NULL, "ns1:SoapWireConnectionPointDescr"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapWireConnectionPointDescr(soap, tag, &n, "ns1:SoapWireConnectionPointDescr"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapWireConnectionPointDescr * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapWireConnectionPointDescr * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapWireConnectionPointDescr * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapWireConnectionPointDescr * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapWireConnectionPointDescr * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapWireConnectionPointDescr * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapWireConnectionPointDescr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapWireConnectionPointDescr * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapWireConnectionPointDescr * >*)p = *(std::vector<ns1__SoapWireConnectionPointDescr * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, std::vector<ns1__SoapEventParameterDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, const std::vector<ns1__SoapEventParameterDescriptor * >*a)
{
	for (std::vector<ns1__SoapEventParameterDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapEventParameterDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapEventParameterDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapEventParameterDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapEventParameterDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapEventParameterDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapEventParameterDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(soap, -1)))
		return NULL;
	ns1__SoapEventParameterDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapEventParameterDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor, sizeof(ns1__SoapEventParameterDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapEventParameterDescriptor(soap, tag, NULL, "ns1:SoapEventParameterDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapEventParameterDescriptor(soap, tag, &n, "ns1:SoapEventParameterDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapEventParameterDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapEventParameterDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapEventParameterDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapEventParameterDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapEventParameterDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapEventParameterDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapEventParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapEventParameterDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapEventParameterDescriptor * >*)p = *(std::vector<ns1__SoapEventParameterDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, std::vector<ns1__SoapEventDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, const std::vector<ns1__SoapEventDescriptor * >*a)
{
	for (std::vector<ns1__SoapEventDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapEventDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapEventDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapEventDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapEventDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapEventDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapEventDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(soap, -1)))
		return NULL;
	ns1__SoapEventDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapEventDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventDescriptor, sizeof(ns1__SoapEventDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapEventDescriptor(soap, tag, NULL, "ns1:SoapEventDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapEventDescriptor(soap, tag, &n, "ns1:SoapEventDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapEventDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapEventDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapEventDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapEventDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapEventDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapEventDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapEventDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapEventDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapEventDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapEventDescriptor * >*)p = *(std::vector<ns1__SoapEventDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, std::vector<ns1__SoapCommandParameterDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, const std::vector<ns1__SoapCommandParameterDescriptor * >*a)
{
	for (std::vector<ns1__SoapCommandParameterDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapCommandParameterDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapCommandParameterDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapCommandParameterDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapCommandParameterDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapCommandParameterDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapCommandParameterDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(soap, -1)))
		return NULL;
	ns1__SoapCommandParameterDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapCommandParameterDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor, sizeof(ns1__SoapCommandParameterDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapCommandParameterDescriptor(soap, tag, NULL, "ns1:SoapCommandParameterDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapCommandParameterDescriptor(soap, tag, &n, "ns1:SoapCommandParameterDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapCommandParameterDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapCommandParameterDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapCommandParameterDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapCommandParameterDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapCommandParameterDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapCommandParameterDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapCommandParameterDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapCommandParameterDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapCommandParameterDescriptor * >*)p = *(std::vector<ns1__SoapCommandParameterDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, std::vector<ns1__SoapCommandDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, const std::vector<ns1__SoapCommandDescriptor * >*a)
{
	for (std::vector<ns1__SoapCommandDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapCommandDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapCommandDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapCommandDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapCommandDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapCommandDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapCommandDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(soap, -1)))
		return NULL;
	ns1__SoapCommandDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapCommandDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor, sizeof(ns1__SoapCommandDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapCommandDescriptor(soap, tag, NULL, "ns1:SoapCommandDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapCommandDescriptor(soap, tag, &n, "ns1:SoapCommandDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapCommandDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapCommandDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapCommandDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapCommandDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapCommandDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapCommandDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapCommandDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapCommandDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapCommandDescriptor * >*)p = *(std::vector<ns1__SoapCommandDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, std::vector<ns1__SoapPinoutDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, const std::vector<ns1__SoapPinoutDescriptor * >*a)
{
	for (std::vector<ns1__SoapPinoutDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapPinoutDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapPinoutDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapPinoutDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapPinoutDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapPinoutDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapPinoutDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(soap, -1)))
		return NULL;
	ns1__SoapPinoutDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapPinoutDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor, sizeof(ns1__SoapPinoutDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapPinoutDescriptor(soap, tag, NULL, "ns1:SoapPinoutDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapPinoutDescriptor(soap, tag, &n, "ns1:SoapPinoutDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapPinoutDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapPinoutDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapPinoutDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapPinoutDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapPinoutDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapPinoutDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapPinoutDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapPinoutDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapPinoutDescriptor * >*)p = *(std::vector<ns1__SoapPinoutDescriptor * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, std::vector<ns1__SoapPropertyDescriptor * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, const std::vector<ns1__SoapPropertyDescriptor * >*a)
{
	for (std::vector<ns1__SoapPropertyDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SoapPropertyDescriptor(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, const char *tag, int id, const std::vector<ns1__SoapPropertyDescriptor * >*a, const char *type)
{
	for (std::vector<ns1__SoapPropertyDescriptor * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SoapPropertyDescriptor(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SoapPropertyDescriptor * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, const char *tag, std::vector<ns1__SoapPropertyDescriptor * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(soap, -1)))
		return NULL;
	ns1__SoapPropertyDescriptor *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SoapPropertyDescriptor, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor, sizeof(ns1__SoapPropertyDescriptor), 1))
				break;
			if (!soap_in_PointerTons1__SoapPropertyDescriptor(soap, tag, NULL, "ns1:SoapPropertyDescriptor"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__SoapPropertyDescriptor(soap, tag, &n, "ns1:SoapPropertyDescriptor"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SoapPropertyDescriptor * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapPropertyDescriptor * >);
		if (size)
			*size = sizeof(std::vector<ns1__SoapPropertyDescriptor * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__SoapPropertyDescriptor * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SoapPropertyDescriptor * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SoapPropertyDescriptor * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SoapPropertyDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SoapPropertyDescriptor * > %p -> %p\n", q, p));
	*(std::vector<ns1__SoapPropertyDescriptor * >*)p = *(std::vector<ns1__SoapPropertyDescriptor * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
